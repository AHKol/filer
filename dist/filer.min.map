{"version":3,"sources":["../lib/nodash.js","path.js","shared.js","constants.js","errors.js","../node_modules/node-libs-browser/node_modules/base64-js/index.js","../node_modules/ieee754/index.js","../node_modules/isarray/index.js","../node_modules/node-libs-browser/node_modules/buffer/index.js","buffer.js","providers/indexeddb.js","../node_modules/base64-arraybuffer/lib/base64-arraybuffer.js","providers/websql.js","../node_modules/node-libs-browser/node_modules/process/browser.js","../lib/async.js","providers/memory.js","providers/index.js","shell/environment.js","encoding.js","shell/shell.js","../lib/eventemitter.js","../lib/intercom.js","fs-watcher.js","directory-entry.js","open-file-description.js","super-node.js","node.js","stats.js","filesystem/implementation.js","filesystem/interface.js","index.js"],"names":["ArrayProto","Array","prototype","nativeForEach","forEach","nativeIndexOf","indexOf","nativeSome","some","ObjProto","Object","hasOwnProperty","nativeKeys","keys","breaker","has","obj","key","call","TypeError","push","size","length","identity","value","each","iterator","context","i","any","result","index","list","contains","target","Wrapped","nodash","isArray","module","exports","normalizeArray","parts","allowAboveRoot","up","last","splice","unshift","splitPathRe","splitPath","filename","exec","resolve","resolvedPath","resolvedAbsolute","arguments","path","charAt","split","filter","p","join","normalize","isAbsolute","substr","slice","relative","from","to","trim","arr","start","end","fromParts","toParts","Math","min","samePartsLength","outputParts","concat","dirname","root","dir","basename","ext","f","extname","isNull","guid","replace","c","r","random","v","toString","toUpperCase","nop","u8toArray","u8","array","len","O_READ","O_WRITE","O_CREATE","O_EXCLUSIVE","O_TRUNCATE","O_APPEND","XATTR_CREATE","XATTR_REPLACE","errors","e","errno","errName","defaultMessage","FilerError","msg","name","code","message","stack","Error","create","constructor","pathInfo","FilerBuffer","subject","encoding","nonZero","ArrayBuffer","Uint8Array","Buffer","FILE_SYSTEM_NAME","require","FILE_STORE_NAME","IDB_RW","IDB_RO","Errors","indexedDB","global","mozIndexedDB","webkitIndexedDB","msIndexedDB","IndexedDBContext","db","mode","transaction","objectStore","_get","callback","request","get","onsuccess","event","onerror","error","_put","put","IndexedDB","clear","getObject","getBuffer","err","arrayBuffer","putObject","putBuffer","uint8BackedBuffer","buffer","delete","isSupported","open","that","openRequest","onupgradeneeded","objectStoreNames","deleteObjectStore","createObjectStore","EINVAL","getReadOnlyContext","getReadWriteContext","chars","lookup","charCodeAt","encode","arraybuffer","bytes","base64","substring","decode","bufferLength","encoded1","encoded2","encoded3","encoded4","WSQL_VERSION","WSQL_SIZE","WSQL_DESC","base64ArrayBuffer","WebSQLContext","isReadOnly","getTransaction","onSuccess","rows","item","data","onError","executeSql","WebSQL","JSON","parse","json","stringify","openDatabase","createIndex","cachedSetTimeout","cachedClearTimeout","process","defaultSetTimout","defaultClearTimeout","runTimeout","fun","setTimeout","runClearTimeout","marker","clearTimeout","currentQueue","queue","draining","queueIndex","cleanUpNextTick","drainQueue","timeout","run","Item","noop","nextTick","args","apply","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","prependListener","prependOnceListener","listeners","binding","cwd","chdir","umask","async","setImmediate","fn","eachSeries","completed","iterate","forEachSeries","define","amd","asyncCallback","createDB","pool","MemoryContext","readOnly","Memory","NotSupported","defaults","ENVIRONMENT","TMP","PATH","set","buf","string","Path","Environment","Encoding","Shell","fs","options","defineProperty","cd","stat","stats","ENOTDIR","type","pwd","sh","readFile","Function","touch","updateOnly","createFile","writeFile","updateTimes","now","Date","atime","date","mtime","utimes","cat","files","all","append","ls","pathname","readdir","entries","getDirEntry","entry","nlinks","recursive","items","contents","rm","remove","map","rmdir","ENOTEMPTY","unlink","tempDir","tmp","mkdir","mkdirp","_mkdirp","isDirectory","isFile","parent","removeItem","EventEmitter","createInterface","space","methods","trigger","self","pvt","_on","_off","_trigger","pub","throttle","delay","extend","a","b","localStorage","window","Intercom","origin","lastMessage","receivedIDs","previousValues","storageHandler","_onStorageEvent","document","attachEvent","addEventListener","_transaction","TIMEOUT","WAIT","executed","listening","waitTimer","lock","activeLock","getItem","INDEX_LOCK","setItem","unlock","_cleanup_emit","messages","threshold","THRESHOLD_TTL_EMIT","changed","INDEX_EMIT","timestamp","_cleanup_once","table","INDEX_ONCE","_once_expired","ttl","THRESHOLD_TTL_ONCE","_localStorageChanged","field","currentValue","id","payload","_emit","String","packet","delimiter","supported","destroy","getInstance","intercom","FSWatcher","recursivePathPrefix","onchange","filename_","persistent_","recursive_","close","MODE_FILE","flags","position","Constants","SuperNode","SUPER_NODE_ID","MODE_META","ctime","rnode","Node","xattrs","blksize","undefined","nblocks","ensureID","prop","Stats","fileNode","devName","node","dev","MODE_DIRECTORY","isSymbolicLink","MODE_SYMBOLIC_LINK","isSocket","isFIFO","isCharacterDevice","isBlockDevice","_","isAbsolutePath","isNullPath","ROOT_DIRECTORY_NAME","SYMLOOP_MAX","O_FLAGS","FS_NOMTIME","FS_NOCTIME","DirectoryEntry","OpenFileDescription","standard_check_result_cb","update_node_times","times","update","complete","changes","make_node","parentNode","parentNodeData","parentPath","check_if_node_exists","EEXIST","ENOENT","create_node","update_parent_node_data","update_time","create_node_in_parent","parentDirectoryNode","find_node","followedCount","read_root_directory_node","superNode","check_root_directory_node","EFILESYSTEMERROR","rootDirectoryNode","read_parent_directory_data","get_node_from_parent_directory_data","parentDirectoryData","nodeId","is_symbolic_link","follow_symbolic_link","ELOOP","set_extended_attribute","path_or_fd","flag","set_xattr","ENOATTR","ensure_root_directory","directoryNode","directoryData","write_directory_node","write_directory_data","ensure_super_node","existingNode","make_directory","update_parent_directory_data","check_if_directory_exists","remove_directory","EBUSY","check_if_node_is_directory","check_if_directory_is_empty","remove_directory_node","remove_directory_data","open_file","directoryEntry","fileData","read_directory_data","check_if_file_exists","EISDIR","check_if_symbolic_link","write_file_data","set_file_node","fill","update_directory_data","handle_update_result","replace_data","ofd","offset","return_nbytes","update_file_node","newData","copy","write_data","update_file_data","EIO","_position","newSize","max","read_file_data","read_data","handle_file_data","stat_file","fstat_file","lstat_file","link_node","oldpath","newpath","oldname","oldParentPath","newname","oldDirectoryNode","oldDirectoryData","newDirectoryNode","newDirectoryData","newParentPath","read_directory_entry","check_if_new_file_exists","read_new_directory_data","check_if_old_file_exists","read_old_directory_data","unlink_node","delete_file_data","read_directory","handle_directory_data","make_symbolic_link","srcpath","dstpath","read_link","check_if_symbolic","truncate_file","truncate_file_data","ftruncate_file","utimes_file","update_times","futimes_file","setxattr_file","fsetxattr_file","getxattr_file","get_xattr","fgetxattr_file","removexattr_file","remove_xattr","xattr","fremovexattr_file","validate_flags","validate_file_options","enc","fileMode","pathCheck","check_result","openFileDescription","fd","allocDescriptor","openFiles","releaseDescriptor","EBADF","mknod","fstat","link","read","wrapped_cb","bytesRead","cleanup","fstatResult","nbytes","write","appendFile","exists","cb","getxattr","fgetxattr","setxattr","fsetxattr","removexattr","fremovexattr","lseek","whence","update_descriptor_position","currentTime","futimes","rename","unlink_old_node","symlink","readlink","lstat","truncate","ftruncate","FS_FORMAT","FS_READY","FS_PENDING","FS_ERROR","FS_NODUPEIDCHECK","providers","defaultGuidFn","STDIN","STDOUT","STDERR","FIRST_DESCRIPTOR","impl","maybeCallback","FileSystem","provider","Default","forceFormatting","readyState","stdin","stdout","stderr","nextDescriptor","wrappedGuidFn","guidWithCheck","queueOrRun","operation","watch","listener","watcher","wrappedContext","methodName","broadcastChanges","change","bind","ensureRootDirectory","lastArgIndex","missingCallback","openReadWriteContext","fnArgs"],"mappings":"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","file":"filer.min.map","sourceRoot":"../src","sourcesContent":["// Cherry-picked bits of underscore.js, lodash.js\n\n/**\n * Lo-Dash 2.4.0 <http://lodash.com/>\n * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>\n * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>\n * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n * Available under MIT license <http://lodash.com/license>\n */\nvar ArrayProto = Array.prototype;\nvar nativeForEach = ArrayProto.forEach;\nvar nativeIndexOf = ArrayProto.indexOf;\nvar nativeSome = ArrayProto.some;\n\nvar ObjProto = Object.prototype;\nvar hasOwnProperty = ObjProto.hasOwnProperty;\nvar nativeKeys = Object.keys;\n\nvar breaker = {};\n\nfunction has(obj, key) {\n  return hasOwnProperty.call(obj, key);\n}\n\nvar keys = nativeKeys || function(obj) {\n  if (obj !== Object(obj)) throw new TypeError('Invalid object');\n  var keys = [];\n  for (var key in obj) if (has(obj, key)) keys.push(key);\n  return keys;\n};\n\nfunction size(obj) {\n  if (obj == null) return 0;\n  return (obj.length === +obj.length) ? obj.length : keys(obj).length;\n}\n\nfunction identity(value) {\n  return value;\n}\n\nfunction each(obj, iterator, context) {\n  var i, length;\n  if (obj == null) return;\n  if (nativeForEach && obj.forEach === nativeForEach) {\n    obj.forEach(iterator, context);\n  } else if (obj.length === +obj.length) {\n    for (i = 0, length = obj.length; i < length; i++) {\n      if (iterator.call(context, obj[i], i, obj) === breaker) return;\n    }\n  } else {\n    var keys = keys(obj);\n    for (i = 0, length = keys.length; i < length; i++) {\n      if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;\n    }\n  }\n};\n\nfunction any(obj, iterator, context) {\n  iterator || (iterator = identity);\n  var result = false;\n  if (obj == null) return result;\n  if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n  each(obj, function(value, index, list) {\n    if (result || (result = iterator.call(context, value, index, list))) return breaker;\n  });\n  return !!result;\n};\n\nfunction contains(obj, target) {\n  if (obj == null) return false;\n  if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n  return any(obj, function(value) {\n    return value === target;\n  });\n};\n\nfunction Wrapped(value) {\n  this.value = value;\n}\nWrapped.prototype.has = function(key) {\n  return has(this.value, key);\n};\nWrapped.prototype.contains = function(target) {\n  return contains(this.value, target);\n};\nWrapped.prototype.size = function() {\n  return size(this.value);\n};\n\nfunction nodash(value) {\n  // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor\n  return (value && typeof value == 'object' && !Array.isArray(value) && hasOwnProperty.call(value, '__wrapped__'))\n    ? value\n    : new Wrapped(value);\n}\n\nmodule.exports = nodash;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Based on https://github.com/joyent/node/blob/41e53e557992a7d552a8e23de035f9463da25c99/lib/path.js\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n      /^(\\/?)([\\s\\S]+\\/(?!$)|\\/)?((?:\\.{1,2}$|[\\s\\S]+?)?(\\.[^.\\/]*)?)$/;\nvar splitPath = function(filename) {\n  var result = splitPathRe.exec(filename);\n  return [result[1] || '', result[2] || '', result[3] || '', result[4] || ''];\n};\n\n// path.resolve([from ...], to)\nfunction resolve() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    // XXXidbfs: we don't have process.cwd() so we use '/' as a fallback\n    var path = (i >= 0) ? arguments[i] : '/';\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string' || !path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(resolvedPath.split('/').filter(function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n}\n\n// path.normalize(path)\nfunction normalize(path) {\n  var isAbsolute = path.charAt(0) === '/',\n      trailingSlash = path.substr(-1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(path.split('/').filter(function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  /*\n   if (path && trailingSlash) {\n   path += '/';\n   }\n   */\n\n  return (isAbsolute ? '/' : '') + path;\n}\n\nfunction join() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return normalize(paths.filter(function(p, index) {\n    return p && typeof p === 'string';\n  }).join('/'));\n}\n\n// path.relative(from, to)\nfunction relative(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n}\n\nfunction dirname(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n}\n\nfunction basename(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  // XXXidbfs: node.js just does `return f`\n  return f === \"\" ? \"/\" : f;\n}\n\nfunction extname(path) {\n  return splitPath(path)[3];\n}\n\nfunction isAbsolute(path) {\n  if(path.charAt(0) === '/') {\n    return true;\n  }\n  return false;\n}\n\nfunction isNull(path) {\n  if (('' + path).indexOf('\\u0000') !== -1) {\n    return true;\n  }\n  return false;\n}\n\n// XXXidbfs: we don't support path.exists() or path.existsSync(), which\n// are deprecated, and need a FileSystem instance to work. Use fs.stat().\n\nmodule.exports = {\n  normalize: normalize,\n  resolve: resolve,\n  join: join,\n  relative: relative,\n  sep: '/',\n  delimiter: ':',\n  dirname: dirname,\n  basename: basename,\n  extname: extname,\n  isAbsolute: isAbsolute,\n  isNull: isNull\n};\n","function guid() {\n  return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {\n    var r = Math.random()*16|0, v = c == 'x' ? r : (r&0x3|0x8);\n    return v.toString(16);\n  }).toUpperCase();\n}\n\nfunction nop() {}\n\n/**\n * Convert a Uint8Array to a regular array\n */\nfunction u8toArray(u8) {\n  var array = [];\n  var len = u8.length;\n  for(var i = 0; i < len; i++) {\n    array[i] = u8[i];\n  }\n  return array;\n}\n\nmodule.exports = {\n  guid: guid,\n  u8toArray: u8toArray,\n  nop: nop\n};\n","var O_READ = 'READ';\nvar O_WRITE = 'WRITE';\nvar O_CREATE = 'CREATE';\nvar O_EXCLUSIVE = 'EXCLUSIVE';\nvar O_TRUNCATE = 'TRUNCATE';\nvar O_APPEND = 'APPEND';\nvar XATTR_CREATE = 'CREATE';\nvar XATTR_REPLACE = 'REPLACE';\n\nmodule.exports = {\n  FILE_SYSTEM_NAME: 'local',\n\n  FILE_STORE_NAME: 'files',\n\n  IDB_RO: 'readonly',\n  IDB_RW: 'readwrite',\n\n  WSQL_VERSION: \"1\",\n  WSQL_SIZE: 5 * 1024 * 1024,\n  WSQL_DESC: \"FileSystem Storage\",\n\n  MODE_FILE: 'FILE',\n  MODE_DIRECTORY: 'DIRECTORY',\n  MODE_SYMBOLIC_LINK: 'SYMLINK',\n  MODE_META: 'META',\n\n  SYMLOOP_MAX: 10,\n\n  BINARY_MIME_TYPE: 'application/octet-stream',\n  JSON_MIME_TYPE: 'application/json',\n\n  ROOT_DIRECTORY_NAME: '/', // basename(normalize(path))\n\n  // FS Mount Flags\n  FS_FORMAT: 'FORMAT',\n  FS_NOCTIME: 'NOCTIME',\n  FS_NOMTIME: 'NOMTIME',\n  FS_NODUPEIDCHECK: 'FS_NODUPEIDCHECK',\n\n  // FS File Open Flags\n  O_READ: O_READ,\n  O_WRITE: O_WRITE,\n  O_CREATE: O_CREATE,\n  O_EXCLUSIVE: O_EXCLUSIVE,\n  O_TRUNCATE: O_TRUNCATE,\n  O_APPEND: O_APPEND,\n\n  O_FLAGS: {\n    'r': [O_READ],\n    'r+': [O_READ, O_WRITE],\n    'w': [O_WRITE, O_CREATE, O_TRUNCATE],\n    'w+': [O_WRITE, O_READ, O_CREATE, O_TRUNCATE],\n    'wx': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],\n    'wx+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_TRUNCATE],\n    'a': [O_WRITE, O_CREATE, O_APPEND],\n    'a+': [O_WRITE, O_READ, O_CREATE, O_APPEND],\n    'ax': [O_WRITE, O_CREATE, O_EXCLUSIVE, O_APPEND],\n    'ax+': [O_WRITE, O_READ, O_CREATE, O_EXCLUSIVE, O_APPEND]\n  },\n\n  XATTR_CREATE: XATTR_CREATE,\n  XATTR_REPLACE: XATTR_REPLACE,\n\n  FS_READY: 'READY',\n  FS_PENDING: 'PENDING',\n  FS_ERROR: 'ERROR',\n\n  SUPER_NODE_ID: '00000000-0000-0000-0000-000000000000',\n\n  // Reserved File Descriptors for streams\n  STDIN: 0,\n  STDOUT: 1,\n  STDERR: 2,\n  FIRST_DESCRIPTOR: 3,\n\n  ENVIRONMENT: {\n    TMP: '/tmp',\n    PATH: ''\n  }\n};\n","var errors = {};\n[\n  /**\n   * node.js errors - we only use some of these, add as needed.\n   */\n  //'-1:UNKNOWN:unknown error',\n  //'0:OK:success',\n  //'1:EOF:end of file',\n  //'2:EADDRINFO:getaddrinfo error',\n  //'3:EACCES:permission denied',\n  //'4:EAGAIN:resource temporarily unavailable',\n  //'5:EADDRINUSE:address already in use',\n  //'6:EADDRNOTAVAIL:address not available',\n  //'7:EAFNOSUPPORT:address family not supported',\n  //'8:EALREADY:connection already in progress',\n  '9:EBADF:bad file descriptor',\n  '10:EBUSY:resource busy or locked',\n  //'11:ECONNABORTED:software caused connection abort',\n  //'12:ECONNREFUSED:connection refused',\n  //'13:ECONNRESET:connection reset by peer',\n  //'14:EDESTADDRREQ:destination address required',\n  //'15:EFAULT:bad address in system call argument',\n  //'16:EHOSTUNREACH:host is unreachable',\n  //'17:EINTR:interrupted system call',\n  '18:EINVAL:invalid argument',\n  //'19:EISCONN:socket is already connected',\n  //'20:EMFILE:too many open files',\n  //'21:EMSGSIZE:message too long',\n  //'22:ENETDOWN:network is down',\n  //'23:ENETUNREACH:network is unreachable',\n  //'24:ENFILE:file table overflow',\n  //'25:ENOBUFS:no buffer space available',\n  //'26:ENOMEM:not enough memory',\n  '27:ENOTDIR:not a directory',\n  '28:EISDIR:illegal operation on a directory',\n  //'29:ENONET:machine is not on the network',\n  // errno 30 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n  //'31:ENOTCONN:socket is not connected',\n  //'32:ENOTSOCK:socket operation on non-socket',\n  //'33:ENOTSUP:operation not supported on socket',\n  '34:ENOENT:no such file or directory',\n  //'35:ENOSYS:function not implemented',\n  //'36:EPIPE:broken pipe',\n  //'37:EPROTO:protocol error',\n  //'38:EPROTONOSUPPORT:protocol not supported',\n  //'39:EPROTOTYPE:protocol wrong type for socket',\n  //'40:ETIMEDOUT:connection timed out',\n  //'41:ECHARSET:invalid Unicode character',\n  //'42:EAIFAMNOSUPPORT:address family for hostname not supported',\n  // errno 43 skipped, as per https://github.com/rvagg/node-errno/blob/master/errno.js\n  //'44:EAISERVICE:servname not supported for ai_socktype',\n  //'45:EAISOCKTYPE:ai_socktype not supported',\n  //'46:ESHUTDOWN:cannot send after transport endpoint shutdown',\n  '47:EEXIST:file already exists',\n  //'48:ESRCH:no such process',\n  //'49:ENAMETOOLONG:name too long',\n  //'50:EPERM:operation not permitted',\n  '51:ELOOP:too many symbolic links encountered',\n  //'52:EXDEV:cross-device link not permitted',\n  '53:ENOTEMPTY:directory not empty',\n  //'54:ENOSPC:no space left on device',\n  '55:EIO:i/o error',\n  //'56:EROFS:read-only file system',\n  //'57:ENODEV:no such device',\n  //'58:ESPIPE:invalid seek',\n  //'59:ECANCELED:operation canceled',\n\n  /**\n   * Filer specific errors\n   */\n  '1000:ENOTMOUNTED:not mounted',\n  '1001:EFILESYSTEMERROR:missing super node, use \\'FORMAT\\' flag to format filesystem.',\n  '1002:ENOATTR:attribute does not exist'\n\n].forEach(function(e) {\n  e = e.split(':');\n  var errno = +e[0];\n  var errName = e[1];\n  var defaultMessage = e[2];\n\n  function FilerError(msg, path) {\n    Error.call(this);\n\n    this.name = errName;\n    this.code = errName;\n    this.errno = errno;\n    this.message = msg || defaultMessage;\n    if(path) {\n      this.path = path;\n    }\n    this.stack = (new Error(this.message)).stack;\n  }\n  FilerError.prototype = Object.create(Error.prototype);\n  FilerError.prototype.constructor = FilerError;\n  FilerError.prototype.toString = function() {\n    var pathInfo = this.path ? (', \\'' + this.path + '\\'') : '';\n    return this.name + ': ' + this.message + pathInfo;\n  };\n\n  // We expose the error as both Errors.EINVAL and Errors[18]\n  errors[errName] = errors[errno] = FilerError;\n});\n\nmodule.exports = errors;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","function FilerBuffer (subject, encoding, nonZero) {\n\n  // Automatically turn ArrayBuffer into Uint8Array so that underlying\n  // Buffer code doesn't just throw away and ignore ArrayBuffer data.\n  if (subject instanceof ArrayBuffer) {\n    subject = new Uint8Array(subject);\n  }\n\n  return new Buffer(subject, encoding, nonZero);\n};\n\n// Inherit prototype from Buffer\nFilerBuffer.prototype = Object.create(Buffer.prototype);\nFilerBuffer.prototype.constructor = FilerBuffer;\n\n// Also copy static methods onto FilerBuffer ctor\nObject.keys(Buffer).forEach(function (p) {\n  if (Buffer.hasOwnProperty(p)) {\n    FilerBuffer[p] = Buffer[p];\n  }\n});\n\nmodule.exports = FilerBuffer;\n","var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\nvar FILE_STORE_NAME = require('../constants.js').FILE_STORE_NAME;\nvar IDB_RW = require('../constants.js').IDB_RW;\nvar IDB_RO = require('../constants.js').IDB_RO;\nvar Errors = require('../errors.js');\nvar FilerBuffer = require('../buffer.js');\n\nvar indexedDB = global.indexedDB       ||\n                global.mozIndexedDB    ||\n                global.webkitIndexedDB ||\n                global.msIndexedDB;\n\nfunction IndexedDBContext(db, mode) {\n  var transaction = db.transaction(FILE_STORE_NAME, mode);\n  this.objectStore = transaction.objectStore(FILE_STORE_NAME);\n}\n\nIndexedDBContext.prototype.clear = function(callback) {\n  try {\n    var request = this.objectStore.clear();\n    request.onsuccess = function(event) {\n      callback();\n    };\n    request.onerror = function(error) {\n      callback(error);\n    };\n  } catch(e) {\n    callback(e);\n  }\n};\n\nfunction _get(objectStore, key, callback) {\n  try {\n    var request = objectStore.get(key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function onerror(error) {\n      callback(error);\n    };\n  } catch(e) {\n    callback(e);\n  }\n}\nIndexedDBContext.prototype.getObject = function(key, callback) {\n  _get(this.objectStore, key, callback);\n};\nIndexedDBContext.prototype.getBuffer = function(key, callback) {\n  _get(this.objectStore, key, function(err, arrayBuffer) {\n    if(err) {\n      return callback(err);\n    }\n    callback(null, new FilerBuffer(arrayBuffer));\n  });\n};\n\nfunction _put(objectStore, key, value, callback) {\n  try {\n    var request = objectStore.put(value, key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function onerror(error) {\n      callback(error);\n    };\n  } catch(e) {\n    callback(e);\n  }\n}\nIndexedDBContext.prototype.putObject = function(key, value, callback) {\n  _put(this.objectStore, key, value, callback);\n};\nIndexedDBContext.prototype.putBuffer = function(key, uint8BackedBuffer, callback) {\n  _put(this.objectStore, key, uint8BackedBuffer.buffer, callback);\n};\n\nIndexedDBContext.prototype.delete = function(key, callback) {\n  try {\n    var request = this.objectStore.delete(key);\n    request.onsuccess = function onsuccess(event) {\n      var result = event.target.result;\n      callback(null, result);\n    };\n    request.onerror = function(error) {\n      callback(error);\n    };\n  } catch(e) {\n    callback(e);\n  }\n};\n\n\nfunction IndexedDB(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n  this.db = null;\n}\nIndexedDB.isSupported = function() {\n  return !!indexedDB;\n};\n\nIndexedDB.prototype.open = function(callback) {\n  var that = this;\n\n  // Bail if we already have a db open\n  if(that.db) {\n    return callback();\n  }\n\n  // NOTE: we're not using versioned databases.\n  var openRequest = indexedDB.open(that.name);\n\n  // If the db doesn't exist, we'll create it\n  openRequest.onupgradeneeded = function onupgradeneeded(event) {\n    var db = event.target.result;\n\n    if(db.objectStoreNames.contains(FILE_STORE_NAME)) {\n      db.deleteObjectStore(FILE_STORE_NAME);\n    }\n    db.createObjectStore(FILE_STORE_NAME);\n  };\n\n  openRequest.onsuccess = function onsuccess(event) {\n    that.db = event.target.result;\n    callback();\n  };\n  openRequest.onerror = function onerror(error) {\n    callback(new Errors.EINVAL('IndexedDB cannot be accessed. If private browsing is enabled, disable it.'));\n  };\n};\nIndexedDB.prototype.getReadOnlyContext = function() {\n  // Due to timing issues in Chrome with readwrite vs. readonly indexeddb transactions\n  // always use readwrite so we can make sure pending commits finish before callbacks.\n  // See https://github.com/js-platform/filer/issues/128\n  return new IndexedDBContext(this.db, IDB_RW);\n};\nIndexedDB.prototype.getReadWriteContext = function() {\n  return new IndexedDBContext(this.db, IDB_RW);\n};\n\nmodule.exports = IndexedDB;\n","/*\n * base64-arraybuffer\n * https://github.com/niklasvh/base64-arraybuffer\n *\n * Copyright (c) 2012 Niklas von Hertzen\n * Licensed under the MIT license.\n */\n(function(){\n  \"use strict\";\n\n  var chars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n  // Use a lookup table to find the index.\n  var lookup = new Uint8Array(256);\n  for (var i = 0; i < chars.length; i++) {\n    lookup[chars.charCodeAt(i)] = i;\n  }\n\n  exports.encode = function(arraybuffer) {\n    var bytes = new Uint8Array(arraybuffer),\n    i, len = bytes.length, base64 = \"\";\n\n    for (i = 0; i < len; i+=3) {\n      base64 += chars[bytes[i] >> 2];\n      base64 += chars[((bytes[i] & 3) << 4) | (bytes[i + 1] >> 4)];\n      base64 += chars[((bytes[i + 1] & 15) << 2) | (bytes[i + 2] >> 6)];\n      base64 += chars[bytes[i + 2] & 63];\n    }\n\n    if ((len % 3) === 2) {\n      base64 = base64.substring(0, base64.length - 1) + \"=\";\n    } else if (len % 3 === 1) {\n      base64 = base64.substring(0, base64.length - 2) + \"==\";\n    }\n\n    return base64;\n  };\n\n  exports.decode =  function(base64) {\n    var bufferLength = base64.length * 0.75,\n    len = base64.length, i, p = 0,\n    encoded1, encoded2, encoded3, encoded4;\n\n    if (base64[base64.length - 1] === \"=\") {\n      bufferLength--;\n      if (base64[base64.length - 2] === \"=\") {\n        bufferLength--;\n      }\n    }\n\n    var arraybuffer = new ArrayBuffer(bufferLength),\n    bytes = new Uint8Array(arraybuffer);\n\n    for (i = 0; i < len; i+=4) {\n      encoded1 = lookup[base64.charCodeAt(i)];\n      encoded2 = lookup[base64.charCodeAt(i+1)];\n      encoded3 = lookup[base64.charCodeAt(i+2)];\n      encoded4 = lookup[base64.charCodeAt(i+3)];\n\n      bytes[p++] = (encoded1 << 2) | (encoded2 >> 4);\n      bytes[p++] = ((encoded2 & 15) << 4) | (encoded3 >> 2);\n      bytes[p++] = ((encoded3 & 3) << 6) | (encoded4 & 63);\n    }\n\n    return arraybuffer;\n  };\n})();\n","var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\nvar FILE_STORE_NAME = require('../constants.js').FILE_STORE_NAME;\nvar WSQL_VERSION = require('../constants.js').WSQL_VERSION;\nvar WSQL_SIZE = require('../constants.js').WSQL_SIZE;\nvar WSQL_DESC = require('../constants.js').WSQL_DESC;\nvar Errors = require('../errors.js');\nvar FilerBuffer = require('../buffer.js');\nvar base64ArrayBuffer = require('base64-arraybuffer');\n\nfunction WebSQLContext(db, isReadOnly) {\n  var that = this;\n  this.getTransaction = function(callback) {\n    if(that.transaction) {\n      callback(that.transaction);\n      return;\n    }\n    // Either do readTransaction() (read-only) or transaction() (read/write)\n    db[isReadOnly ? 'readTransaction' : 'transaction'](function(transaction) {\n      that.transaction = transaction;\n      callback(transaction);\n    });\n  };\n}\n\nWebSQLContext.prototype.clear = function(callback) {\n  function onError(transaction, error) {\n    callback(error);\n  }\n  function onSuccess(transaction, result) {\n    callback(null);\n  }\n  this.getTransaction(function(transaction) {\n    transaction.executeSql(\"DELETE FROM \" + FILE_STORE_NAME + \";\",\n                           [], onSuccess, onError);\n  });\n};\n\nfunction _get(getTransaction, key, callback) {\n  function onSuccess(transaction, result) {\n    // If the key isn't found, return null\n    var value = result.rows.length === 0 ? null : result.rows.item(0).data;\n    callback(null, value);\n  }\n  function onError(transaction, error) {\n    callback(error);\n  }\n  getTransaction(function(transaction) {\n    transaction.executeSql(\"SELECT data FROM \" + FILE_STORE_NAME + \" WHERE id = ? LIMIT 1;\",\n                           [key], onSuccess, onError);\n  });\n}\nWebSQLContext.prototype.getObject = function(key, callback) {\n  _get(this.getTransaction, key, function(err, result) {\n    if(err) {\n      return callback(err);\n    }\n\n    try {\n      if(result) {\n        result = JSON.parse(result);\n      }\n    } catch(e) {\n      return callback(e);\n    }\n\n    callback(null, result);\n  });\n};\nWebSQLContext.prototype.getBuffer = function(key, callback) {\n  _get(this.getTransaction, key, function(err, result) {\n    if(err) {\n      return callback(err);\n    }\n\n    // Deal with zero-length ArrayBuffers, which will be encoded as ''\n    if(result || result === '') {\n      var arrayBuffer = base64ArrayBuffer.decode(result);\n      result = new FilerBuffer(arrayBuffer);\n    }\n\n    callback(null, result);\n  });\n};\n\nfunction _put(getTransaction, key, value, callback) {\n  function onSuccess(transaction, result) {\n    callback(null);\n  }\n  function onError(transaction, error) {\n    callback(error);\n  }\n  getTransaction(function(transaction) {\n    transaction.executeSql(\"INSERT OR REPLACE INTO \" + FILE_STORE_NAME + \" (id, data) VALUES (?, ?);\",\n                           [key, value], onSuccess, onError);\n  });\n}\nWebSQLContext.prototype.putObject = function(key, value, callback) {\n  var json = JSON.stringify(value);\n  _put(this.getTransaction, key, json, callback);\n};\nWebSQLContext.prototype.putBuffer = function(key, uint8BackedBuffer, callback) {\n  var base64 = base64ArrayBuffer.encode(uint8BackedBuffer.buffer);\n  _put(this.getTransaction, key, base64, callback);\n};\n\nWebSQLContext.prototype.delete = function(key, callback) {\n  function onSuccess(transaction, result) {\n    callback(null);\n  }\n  function onError(transaction, error) {\n    callback(error);\n  }\n  this.getTransaction(function(transaction) {\n    transaction.executeSql(\"DELETE FROM \" + FILE_STORE_NAME + \" WHERE id = ?;\",\n                           [key], onSuccess, onError);\n  });\n};\n\n\nfunction WebSQL(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n  this.db = null;\n}\nWebSQL.isSupported = function() {\n  return !!global.openDatabase;\n};\n\nWebSQL.prototype.open = function(callback) {\n  var that = this;\n\n  // Bail if we already have a db open\n  if(that.db) {\n    return callback();\n  }\n\n  var db = global.openDatabase(that.name, WSQL_VERSION, WSQL_DESC, WSQL_SIZE);\n  if(!db) {\n    callback(\"[WebSQL] Unable to open database.\");\n    return;\n  }\n\n  function onError(transaction, error) {\n    if (error.code === 5) {\n      callback(new Errors.EINVAL('WebSQL cannot be accessed. If private browsing is enabled, disable it.'));\n    }\n    callback(error);\n  }\n  function onSuccess(transaction, result) {\n    that.db = db;\n    callback();\n  }\n\n  // Create the table and index we'll need to store the fs data.\n  db.transaction(function(transaction) {\n    function createIndex(transaction) {\n      transaction.executeSql(\"CREATE INDEX IF NOT EXISTS idx_\" + FILE_STORE_NAME + \"_id\" +\n                             \" on \" + FILE_STORE_NAME + \" (id);\",\n                             [], onSuccess, onError);\n    }\n    transaction.executeSql(\"CREATE TABLE IF NOT EXISTS \" + FILE_STORE_NAME + \" (id unique, data TEXT);\",\n                           [], createIndex, onError);\n  });\n};\nWebSQL.prototype.getReadOnlyContext = function() {\n  return new WebSQLContext(this.db, true);\n};\nWebSQL.prototype.getReadWriteContext = function() {\n  return new WebSQLContext(this.db, false);\n};\n\nmodule.exports = WebSQL;\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*global setImmediate: false, setTimeout: false, console: false */\n\n/**\n * async.js shim, based on https://raw.github.com/caolan/async/master/lib/async.js Feb 18, 2014\n * Used under MIT - https://github.com/caolan/async/blob/master/LICENSE\n */\n\n(function () {\n\n    var async = {};\n\n    // async.js functions used in Filer\n\n    //// nextTick implementation with browser-compatible fallback ////\n    if (typeof process === 'undefined' || !(process.nextTick)) {\n        if (typeof setImmediate === 'function') {\n            async.nextTick = function (fn) {\n                // not a direct alias for IE10 compatibility\n                setImmediate(fn);\n            };\n            async.setImmediate = async.nextTick;\n        }\n        else {\n            async.nextTick = function (fn) {\n                setTimeout(fn, 0);\n            };\n            async.setImmediate = async.nextTick;\n        }\n    }\n    else {\n        async.nextTick = process.nextTick;\n        if (typeof setImmediate !== 'undefined') {\n            async.setImmediate = function (fn) {\n              // not a direct alias for IE10 compatibility\n              setImmediate(fn);\n            };\n        }\n        else {\n            async.setImmediate = async.nextTick;\n        }\n    }\n\n    async.eachSeries = function (arr, iterator, callback) {\n        callback = callback || function () {};\n        if (!arr.length) {\n            return callback();\n        }\n        var completed = 0;\n        var iterate = function () {\n            iterator(arr[completed], function (err) {\n                if (err) {\n                    callback(err);\n                    callback = function () {};\n                }\n                else {\n                    completed += 1;\n                    if (completed >= arr.length) {\n                        callback();\n                    }\n                    else {\n                        iterate();\n                    }\n                }\n            });\n        };\n        iterate();\n    };\n    async.forEachSeries = async.eachSeries;\n\n    // AMD / RequireJS\n    if (typeof define !== 'undefined' && define.amd) {\n        define([], function () {\n            return async;\n        });\n    }\n    // Node.js\n    else if (typeof module !== 'undefined' && module.exports) {\n        module.exports = async;\n    }\n    // included directly via <script> tag\n    else {\n        root.async = async;\n    }\n\n}());\n","var FILE_SYSTEM_NAME = require('../constants.js').FILE_SYSTEM_NAME;\n// NOTE: prefer setImmediate to nextTick for proper recursion yielding.\n// see https://github.com/js-platform/filer/pull/24\nvar asyncCallback = require('../../lib/async.js').setImmediate;\n\n/**\n * Make shared in-memory DBs possible when using the same name.\n */\nvar createDB = (function() {\n  var pool = {};\n  return function getOrCreate(name) {\n    if(!pool.hasOwnProperty(name)) {\n      pool[name] = {};\n    }\n    return pool[name];\n  };\n}());\n\nfunction MemoryContext(db, readOnly) {\n  this.readOnly = readOnly;\n  this.objectStore = db;\n}\n\nMemoryContext.prototype.clear = function(callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback(\"[MemoryContext] Error: write operation on read only context\");\n    });\n    return;\n  }\n  var objectStore = this.objectStore;\n  Object.keys(objectStore).forEach(function(key){\n    delete objectStore[key];\n  });\n  asyncCallback(callback);\n};\n\n// Memory context doesn't care about differences between Object and Buffer\nMemoryContext.prototype.getObject =\nMemoryContext.prototype.getBuffer =\nfunction(key, callback) {\n  var that = this;\n  asyncCallback(function() {\n    callback(null, that.objectStore[key]);\n  });\n};\nMemoryContext.prototype.putObject =\nMemoryContext.prototype.putBuffer =\nfunction(key, value, callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback(\"[MemoryContext] Error: write operation on read only context\");\n    });\n    return;\n  }\n  this.objectStore[key] = value;\n  asyncCallback(callback);\n};\n\nMemoryContext.prototype.delete = function(key, callback) {\n  if(this.readOnly) {\n    asyncCallback(function() {\n      callback(\"[MemoryContext] Error: write operation on read only context\");\n    });\n    return;\n  }\n  delete this.objectStore[key];\n  asyncCallback(callback);\n};\n\n\nfunction Memory(name) {\n  this.name = name || FILE_SYSTEM_NAME;\n}\nMemory.isSupported = function() {\n  return true;\n};\n\nMemory.prototype.open = function(callback) {\n  this.db = createDB(this.name);\n  asyncCallback(callback);\n};\nMemory.prototype.getReadOnlyContext = function() {\n  return new MemoryContext(this.db, true);\n};\nMemory.prototype.getReadWriteContext = function() {\n  return new MemoryContext(this.db, false);\n};\n\nmodule.exports = Memory;\n","var IndexedDB = require('./indexeddb.js');\nvar WebSQL = require('./websql.js');\nvar Memory = require('./memory.js');\n\nmodule.exports = {\n  IndexedDB: IndexedDB,\n  WebSQL: WebSQL,\n  Memory: Memory,\n\n  /**\n   * Convenience Provider references\n   */\n\n  // The default provider to use when none is specified\n  Default: IndexedDB,\n\n  // The Fallback provider does automatic fallback checks\n  Fallback: (function() {\n    if(IndexedDB.isSupported()) {\n      return IndexedDB;\n    }\n\n    if(WebSQL.isSupported()) {\n      return WebSQL;\n    }\n\n    function NotSupported() {\n      throw \"[Filer Error] Your browser doesn't support IndexedDB or WebSQL.\";\n    }\n    NotSupported.isSupported = function() {\n      return false;\n    };\n    return NotSupported;\n  }())\n};\n","var defaults = require('../constants.js').ENVIRONMENT;\n\nmodule.exports = function Environment(env) {\n  env = env || {};\n  env.TMP = env.TMP || defaults.TMP;\n  env.PATH = env.PATH || defaults.PATH;\n\n  this.get = function(name) {\n    return env[name];\n  };\n\n  this.set = function(name, value) {\n    env[name] = value;\n  };\n};\n","// Adapt encodings to work with Buffer or Uint8Array, they expect the latter\nfunction decode(buf) {\n  return buf.toString('utf8');\n}\n\nfunction encode(string) {\n  return new Buffer(string, 'utf8');\n}\n\nmodule.exports = {\n  encode: encode,\n  decode: decode\n};\n","var Path = require('../path.js');\nvar Errors = require('../errors.js');\nvar Environment = require('./environment.js');\nvar async = require('../../lib/async.js');\nvar Encoding = require('../encoding.js');\n\nfunction Shell(fs, options) {\n  options = options || {};\n\n  var env = new Environment(options.env);\n  var cwd = '/';\n\n  /**\n   * The bound FileSystem (cannot be changed)\n   */\n  Object.defineProperty(this, 'fs', {\n    get: function() { return fs; },\n    enumerable: true\n  });\n\n  /**\n   * The shell's environment (e.g., for things like\n   * path, tmp, and other env vars). Use env.get()\n   * and env.set() to work with variables.\n   */\n  Object.defineProperty(this, 'env', {\n    get: function() { return env; },\n    enumerable: true\n  });\n\n  /**\n   * Change the current working directory. We\n   * include `cd` on the `this` vs. proto so that\n   * we can access cwd without exposing it externally.\n   */\n  this.cd = function(path, callback) {\n    path = Path.resolve(cwd, path);\n    // Make sure the path actually exists, and is a dir\n    fs.stat(path, function(err, stats) {\n      if(err) {\n        callback(new Errors.ENOTDIR(null, path));\n        return;\n      }\n      if(stats.type === 'DIRECTORY') {\n        cwd = path;\n        callback();\n      } else {\n        callback(new Errors.ENOTDIR(null, path));\n      }\n    });\n  };\n\n  /**\n   * Get the current working directory (changed with `cd()`)\n   */\n  this.pwd = function() {\n    return cwd;\n  };\n}\n\n/**\n * Execute the .js command located at `path`. Such commands\n * should assume the existence of 3 arguments, which will be\n * defined at runtime:\n *\n *   * fs - the current shell's bound filesystem object\n *   * args - a list of arguments for the command, or an empty list if none\n *   * callback - a callback function(error, result) to call when done.\n *\n * The .js command's contents should be the body of a function\n * that looks like this:\n *\n * function(fs, args, callback) {\n *   // .js code here\n * }\n */\nShell.prototype.exec = function(path, args, callback) {\n  /* jshint evil:true */\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof args === 'function') {\n    callback = args;\n    args = [];\n  }\n  args = args || [];\n  callback = callback || function(){};\n  path = Path.resolve(sh.pwd(), path);\n\n  fs.readFile(path, \"utf8\", function(error, data) {\n    if(error) {\n      callback(error);\n      return;\n    }\n    try {\n      var cmd = new Function('fs', 'args', 'callback', data);\n      cmd(fs, args, callback);\n    } catch(e) {\n      callback(e);\n    }\n  });\n};\n\n/**\n * Create a file if it does not exist, or update access and\n * modified times if it does. Valid options include:\n *\n *  * updateOnly - whether to create the file if missing (defaults to false)\n *  * date - use the provided Date value instead of current date/time\n */\nShell.prototype.touch = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n  path = Path.resolve(sh.pwd(), path);\n\n  function createFile(path) {\n    fs.writeFile(path, '', callback);\n  }\n\n  function updateTimes(path) {\n    var now = Date.now();\n    var atime = options.date || now;\n    var mtime = options.date || now;\n\n    fs.utimes(path, atime, mtime, callback);\n  }\n\n  fs.stat(path, function(error, stats) {\n    if(error) {\n      if(options.updateOnly === true) {\n        callback();\n      } else {\n        createFile(path);\n      }\n    } else {\n      updateTimes(path);\n    }\n  });\n};\n\n/**\n * Concatenate multiple files into a single String, with each\n * file separated by a newline. The `files` argument should\n * be a String (path to single file) or an Array of Strings\n * (multiple file paths).\n */\nShell.prototype.cat = function(files, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  var all = '';\n  callback = callback || function(){};\n\n  if(!files) {\n    callback(new Errors.EINVAL('Missing files argument'));\n    return;\n  }\n\n  files = typeof files === 'string' ? [ files ] : files;\n\n  function append(item, callback) {\n    var filename = Path.resolve(sh.pwd(), item);\n    fs.readFile(filename, 'utf8', function(error, data) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      all += data + '\\n';\n      callback();\n    });\n  }\n\n  async.eachSeries(files, append, function(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, all.replace(/\\n$/, ''));\n    }\n  });\n};\n\n/**\n * Get the listing of a directory, returning an array of\n * file entries in the following form:\n *\n * {\n *   path: <String> the basename of the directory entry\n *   links: <Number> the number of links to the entry\n *   size: <Number> the size in bytes of the entry\n *   modified: <Number> the last modified date/time\n *   type: <String> the type of the entry\n *   contents: <Array> an optional array of child entries\n * }\n *\n * By default ls() gives a shallow listing. If you want\n * to follow directories as they are encountered, use\n * the `recursive=true` option.\n */\nShell.prototype.ls = function(dir, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  if(!dir) {\n    callback(new Errors.EINVAL('Missing dir argument'));\n    return;\n  }\n\n  function list(path, callback) {\n    var pathname = Path.resolve(sh.pwd(), path);\n    var result = [];\n\n    fs.readdir(pathname, function(error, entries) {\n      if(error) {\n        callback(error);\n        return;\n      }\n\n      function getDirEntry(name, callback) {\n        name = Path.join(pathname, name);\n        fs.stat(name, function(error, stats) {\n          if(error) {\n            callback(error);\n            return;\n          }\n          var entry = {\n            path: Path.basename(name),\n            links: stats.nlinks,\n            size: stats.size,\n            modified: stats.mtime,\n            type: stats.type\n          };\n\n          if(options.recursive && stats.type === 'DIRECTORY') {\n            list(Path.join(pathname, entry.path), function(error, items) {\n              if(error) {\n                callback(error);\n                return;\n              }\n              entry.contents = items;\n              result.push(entry);\n              callback();\n            });\n          } else {\n            result.push(entry);\n            callback();\n          }\n        });\n      }\n\n      async.eachSeries(entries, getDirEntry, function(error) {\n        callback(error, result);\n      });\n    });\n  }\n\n  list(dir, callback);\n};\n\n/**\n * Removes the file or directory at `path`. If `path` is a file\n * it will be removed. If `path` is a directory, it will be\n * removed if it is empty, otherwise the callback will receive\n * an error. In order to remove non-empty directories, use the\n * `recursive=true` option.\n */\nShell.prototype.rm = function(path, options, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  if(typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  options = options || {};\n  callback = callback || function(){};\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n\n  function remove(pathname, callback) {\n    pathname = Path.resolve(sh.pwd(), pathname);\n    fs.stat(pathname, function(error, stats) {\n      if(error) {\n        callback(error);\n        return;\n      }\n\n      // If this is a file, delete it and we're done\n      if(stats.type === 'FILE') {\n        fs.unlink(pathname, callback);\n        return;\n      }\n\n      // If it's a dir, check if it's empty\n      fs.readdir(pathname, function(error, entries) {\n        if(error) {\n          callback(error);\n          return;\n        }\n\n        // If dir is empty, delete it and we're done\n        if(entries.length === 0) {\n          fs.rmdir(pathname, callback);\n          return;\n        }\n\n        // If not, see if we're allowed to delete recursively\n        if(!options.recursive) {\n          callback(new Errors.ENOTEMPTY(null, pathname));\n          return;\n        }\n\n        // Remove each dir entry recursively, then delete the dir.\n        entries = entries.map(function(filename) {\n          // Root dir entries absolutely\n          return Path.join(pathname, filename);\n        });\n        async.eachSeries(entries, remove, function(error) {\n          if(error) {\n            callback(error);\n            return;\n          }\n          fs.rmdir(pathname, callback);\n        });\n      });\n    });\n  }\n\n  remove(path, callback);\n};\n\n/**\n * Gets the path to the temporary directory, creating it if not\n * present. The directory used is the one specified in\n * env.TMP. The callback receives (error, tempDirName).\n */\nShell.prototype.tempDir = function(callback) {\n  var sh = this;\n  var fs = sh.fs;\n  var tmp = sh.env.get('TMP');\n  callback = callback || function(){};\n\n  // Try and create it, and it will either work or fail\n  // but either way it's now there.\n  fs.mkdir(tmp, function(err) {\n    callback(null, tmp);\n  });\n};\n\n/**\n * Recursively creates the directory at `path`. If the parent\n * of `path` does not exist, it will be created.\n * Based off EnsureDir by Sam X. Xu\n * https://www.npmjs.org/package/ensureDir\n * MIT License\n */\nShell.prototype.mkdirp = function(path, callback) {\n  var sh = this;\n  var fs = sh.fs;\n  callback = callback || function(){};\n\n  if(!path) {\n    callback(new Errors.EINVAL('Missing path argument'));\n    return;\n  }\n  else if (path === '/') {\n    callback();\n    return;\n  }\n  function _mkdirp(path, callback) {\n    fs.stat(path, function (err, stat) {\n      if(stat) {\n        if(stat.isDirectory()) {\n          callback();\n          return;\n        }\n        else if (stat.isFile()) {\n          callback(new Errors.ENOTDIR(null, path));\n          return;\n        }\n      }\n      else if (err && err.code !== 'ENOENT') {\n        callback(err);\n        return;\n      }\n      else {\n        var parent = Path.dirname(path);\n        if(parent === '/') {\n          fs.mkdir(path, function (err) {\n            if (err && err.code != 'EEXIST') {\n              callback(err);\n              return;\n            }\n            callback();\n            return;\n          });\n        }\n        else {\n          _mkdirp(parent, function (err) {\n            if (err) return callback(err);\n            fs.mkdir(path, function (err) {\n              if (err && err.code != 'EEXIST') {\n                callback(err);\n                return;\n              }\n              callback();\n              return;\n            });\n          });\n        }\n      }\n    });\n  }\n\n  _mkdirp(path, callback);\n};\n\nmodule.exports = Shell;\n","// Based on https://github.com/diy/intercom.js/blob/master/lib/events.js\n// Copyright 2012 DIY Co Apache License, Version 2.0\n// http://www.apache.org/licenses/LICENSE-2.0\n\nfunction removeItem(item, array) {\n  for (var i = array.length - 1; i >= 0; i--) {\n    if (array[i] === item) {\n      array.splice(i, 1);\n    }\n  }\n  return array;\n}\n\nvar EventEmitter = function() {};\n\nEventEmitter.createInterface = function(space) {\n  var methods = {};\n\n  methods.on = function(name, fn) {\n    if (typeof this[space] === 'undefined') {\n      this[space] = {};\n    }\n    if (!this[space].hasOwnProperty(name)) {\n      this[space][name] = [];\n    }\n    this[space][name].push(fn);\n  };\n\n  methods.off = function(name, fn) {\n    if (typeof this[space] === 'undefined') return;\n    if (this[space].hasOwnProperty(name)) {\n      removeItem(fn, this[space][name]);\n    }\n  };\n\n  methods.trigger = function(name) {\n    if (typeof this[space] !== 'undefined' && this[space].hasOwnProperty(name)) {\n      var args = Array.prototype.slice.call(arguments, 1);\n      for (var i = 0; i < this[space][name].length; i++) {\n        this[space][name][i].apply(this[space][name][i], args);\n      }\n    }\n  };\n\n  methods.removeAllListeners = function(name) {\n    if (typeof this[space] === 'undefined') return;\n    var self = this;\n    self[space][name].forEach(function(fn) {\n      self.off(name, fn);\n    });\n  };\n\n  return methods;\n};\n\nvar pvt = EventEmitter.createInterface('_handlers');\nEventEmitter.prototype._on = pvt.on;\nEventEmitter.prototype._off = pvt.off;\nEventEmitter.prototype._trigger = pvt.trigger;\n\nvar pub = EventEmitter.createInterface('handlers');\nEventEmitter.prototype.on = function() {\n  pub.on.apply(this, arguments);\n  Array.prototype.unshift.call(arguments, 'on');\n  this._trigger.apply(this, arguments);\n};\nEventEmitter.prototype.off = pub.off;\nEventEmitter.prototype.trigger = pub.trigger;\nEventEmitter.prototype.removeAllListeners = pub.removeAllListeners;\n\nmodule.exports = EventEmitter;\n","// Based on https://github.com/diy/intercom.js/blob/master/lib/intercom.js\n// Copyright 2012 DIY Co Apache License, Version 2.0\n// http://www.apache.org/licenses/LICENSE-2.0\n\nvar EventEmitter = require('./eventemitter.js');\nvar guid = require('../src/shared.js').guid;\n\nfunction throttle(delay, fn) {\n  var last = 0;\n  return function() {\n    var now = Date.now();\n    if (now - last > delay) {\n      last = now;\n      fn.apply(this, arguments);\n    }\n  };\n}\n\nfunction extend(a, b) {\n  if (typeof a === 'undefined' || !a) { a = {}; }\n  if (typeof b === 'object') {\n    for (var key in b) {\n      if (b.hasOwnProperty(key)) {\n        a[key] = b[key];\n      }\n    }\n  }\n  return a;\n}\n\nvar localStorage = (function(window) {\n  if (typeof window === 'undefined' ||\n      typeof window.localStorage === 'undefined') {\n    return {\n      getItem : function() {},\n      setItem : function() {},\n      removeItem : function() {}\n    };\n  }\n  return window.localStorage;\n}(global));\n\nfunction Intercom() {\n  var self = this;\n  var now = Date.now();\n\n  this.origin         = guid();\n  this.lastMessage    = now;\n  this.receivedIDs    = {};\n  this.previousValues = {};\n\n  var storageHandler = function() {\n    self._onStorageEvent.apply(self, arguments);\n  };\n\n  // If we're in node.js, skip event registration\n  if (typeof document === 'undefined') {\n    return;\n  }\n\n  if (document.attachEvent) {\n    document.attachEvent('onstorage', storageHandler);\n  } else {\n    global.addEventListener('storage', storageHandler, false);\n  }\n}\n\nIntercom.prototype._transaction = function(fn) {\n  var TIMEOUT   = 1000;\n  var WAIT      = 20;\n  var self      = this;\n  var executed  = false;\n  var listening = false;\n  var waitTimer = null;\n\n  function lock() {\n    if (executed) {\n      return;\n    }\n\n    var now = Date.now();\n    var activeLock = localStorage.getItem(INDEX_LOCK)|0;\n    if (activeLock && now - activeLock < TIMEOUT) {\n      if (!listening) {\n        self._on('storage', lock);\n        listening = true;\n      }\n      waitTimer = setTimeout(lock, WAIT);\n      return;\n    }\n    executed = true;\n    localStorage.setItem(INDEX_LOCK, now);\n\n    fn();\n    unlock();\n  }\n\n  function unlock() {\n    if (listening) {\n      self._off('storage', lock);\n    }\n    if (waitTimer) {\n      clearTimeout(waitTimer);\n    }\n    localStorage.removeItem(INDEX_LOCK);\n  }\n\n  lock();\n};\n\nIntercom.prototype._cleanup_emit = throttle(100, function() {\n  var self = this;\n\n  self._transaction(function() {\n    var now = Date.now();\n    var threshold = now - THRESHOLD_TTL_EMIT;\n    var changed = 0;\n    var messages;\n\n    try {\n      messages = JSON.parse(localStorage.getItem(INDEX_EMIT) || '[]');\n    } catch(e) {\n      messages = [];\n    }\n    for (var i = messages.length - 1; i >= 0; i--) {\n      if (messages[i].timestamp < threshold) {\n        messages.splice(i, 1);\n        changed++;\n      }\n    }\n    if (changed > 0) {\n      localStorage.setItem(INDEX_EMIT, JSON.stringify(messages));\n    }\n  });\n});\n\nIntercom.prototype._cleanup_once = throttle(100, function() {\n  var self = this;\n\n  self._transaction(function() {\n    var timestamp, ttl, key;\n    var table;\n    var now  = Date.now();\n    var changed = 0;\n\n    try {\n      table = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');\n    } catch(e) {\n      table = {};\n    }\n    for (key in table) {\n      if (self._once_expired(key, table)) {\n        delete table[key];\n        changed++;\n      }\n    }\n\n    if (changed > 0) {\n      localStorage.setItem(INDEX_ONCE, JSON.stringify(table));\n    }\n  });\n});\n\nIntercom.prototype._once_expired = function(key, table) {\n  if (!table) {\n    return true;\n  }\n  if (!table.hasOwnProperty(key)) {\n    return true;\n  }\n  if (typeof table[key] !== 'object') {\n    return true;\n  }\n\n  var ttl = table[key].ttl || THRESHOLD_TTL_ONCE;\n  var now = Date.now();\n  var timestamp = table[key].timestamp;\n  return timestamp < now - ttl;\n};\n\nIntercom.prototype._localStorageChanged = function(event, field) {\n  if (event && event.key) {\n    return event.key === field;\n  }\n\n  var currentValue = localStorage.getItem(field);\n  if (currentValue === this.previousValues[field]) {\n    return false;\n  }\n  this.previousValues[field] = currentValue;\n  return true;\n};\n\nIntercom.prototype._onStorageEvent = function(event) {\n  event = event || global.event;\n  var self = this;\n\n  if (this._localStorageChanged(event, INDEX_EMIT)) {\n    this._transaction(function() {\n      var now = Date.now();\n      var data = localStorage.getItem(INDEX_EMIT);\n      var messages;\n\n      try {\n        messages = JSON.parse(data || '[]');\n      } catch(e) {\n        messages = [];\n      }\n      for (var i = 0; i < messages.length; i++) {\n        if (messages[i].origin === self.origin) continue;\n        if (messages[i].timestamp < self.lastMessage) continue;\n        if (messages[i].id) {\n          if (self.receivedIDs.hasOwnProperty(messages[i].id)) continue;\n          self.receivedIDs[messages[i].id] = true;\n        }\n        self.trigger(messages[i].name, messages[i].payload);\n      }\n      self.lastMessage = now;\n    });\n  }\n\n  this._trigger('storage', event);\n};\n\nIntercom.prototype._emit = function(name, message, id) {\n  id = (typeof id === 'string' || typeof id === 'number') ? String(id) : null;\n  if (id && id.length) {\n    if (this.receivedIDs.hasOwnProperty(id)) return;\n    this.receivedIDs[id] = true;\n  }\n\n  var packet = {\n    id        : id,\n    name      : name,\n    origin    : this.origin,\n    timestamp : Date.now(),\n    payload   : message\n  };\n\n  var self = this;\n  this._transaction(function() {\n    var data = localStorage.getItem(INDEX_EMIT) || '[]';\n    var delimiter = (data === '[]') ? '' : ',';\n    data = [data.substring(0, data.length - 1), delimiter, JSON.stringify(packet), ']'].join('');\n    localStorage.setItem(INDEX_EMIT, data);\n    self.trigger(name, message);\n\n    setTimeout(function() {\n      self._cleanup_emit();\n    }, 50);\n  });\n};\n\nIntercom.prototype.emit = function(name, message) {\n  this._emit.apply(this, arguments);\n  this._trigger('emit', name, message);\n};\n\nIntercom.prototype.once = function(key, fn, ttl) {\n  if (!Intercom.supported) {\n    return;\n  }\n\n  var self = this;\n  this._transaction(function() {\n    var data;\n    try {\n      data = JSON.parse(localStorage.getItem(INDEX_ONCE) || '{}');\n    } catch(e) {\n      data = {};\n    }\n    if (!self._once_expired(key, data)) {\n      return;\n    }\n\n    data[key] = {};\n    data[key].timestamp = Date.now();\n    if (typeof ttl === 'number') {\n      data[key].ttl = ttl * 1000;\n    }\n\n    localStorage.setItem(INDEX_ONCE, JSON.stringify(data));\n    fn();\n\n    setTimeout(function() {\n      self._cleanup_once();\n    }, 50);\n  });\n};\n\nextend(Intercom.prototype, EventEmitter.prototype);\n\nIntercom.supported = (typeof localStorage !== 'undefined');\n\nvar INDEX_EMIT = 'intercom';\nvar INDEX_ONCE = 'intercom_once';\nvar INDEX_LOCK = 'intercom_lock';\n\nvar THRESHOLD_TTL_EMIT = 50000;\nvar THRESHOLD_TTL_ONCE = 1000 * 3600;\n\nIntercom.destroy = function() {\n  localStorage.removeItem(INDEX_LOCK);\n  localStorage.removeItem(INDEX_EMIT);\n  localStorage.removeItem(INDEX_ONCE);\n};\n\nIntercom.getInstance = (function() {\n  var intercom;\n  return function() {\n    if (!intercom) {\n      intercom = new Intercom();\n    }\n    return intercom;\n  };\n})();\n\nmodule.exports = Intercom;\n","var EventEmitter = require('../lib/eventemitter.js');\nvar Path = require('./path.js');\nvar Intercom = require('../lib/intercom.js');\n\n/**\n * FSWatcher based on node.js' FSWatcher\n * see https://github.com/joyent/node/blob/master/lib/fs.js\n */\nfunction FSWatcher() {\n  EventEmitter.call(this);\n  var self = this;\n  var recursive = false;\n  var recursivePathPrefix;\n  var filename;\n\n  function onchange(path) {\n    // Watch for exact filename, or parent path when recursive is true.\n    if(filename === path || (recursive && path.indexOf(recursivePathPrefix) === 0)) {\n      self.trigger('change', 'change', path);\n    }\n  }\n\n  // We support, but ignore the second arg, which node.js uses.\n  self.start = function(filename_, persistent_, recursive_) {\n    // Bail if we've already started (and therefore have a filename);\n    if(filename) {\n      return;\n    }\n\n    if(Path.isNull(filename_)) {\n      throw new Error('Path must be a string without null bytes.');\n    }\n\n    // TODO: get realpath for symlinks on filename...\n\n    // Filer's Path.normalize strips trailing slashes, which we use here.\n    // See https://github.com/js-platform/filer/issues/105\n    filename = Path.normalize(filename_);\n\n    // Whether to watch beneath this path or not\n    recursive = recursive_ === true;\n    // If recursive, construct a path prefix portion for comparisons later\n    // (i.e., '/path' becomes '/path/' so we can search within a filename for the\n    // prefix). We also take care to allow for '/' on its own.\n    if(recursive) {\n      recursivePathPrefix = filename === '/' ? '/' : filename + '/';\n    }\n\n    var intercom = Intercom.getInstance();\n    intercom.on('change', onchange);\n  };\n\n  self.close = function() {\n    var intercom = Intercom.getInstance();\n    intercom.off('change', onchange);\n    self.removeAllListeners('change');\n  };\n}\nFSWatcher.prototype = new EventEmitter();\nFSWatcher.prototype.constructor = FSWatcher;\n\nmodule.exports = FSWatcher;\n","var MODE_FILE = require('./constants.js').MODE_FILE;\n\nmodule.exports = function DirectoryEntry(id, type) {\n  this.id = id;\n  this.type = type || MODE_FILE;\n};\n","module.exports = function OpenFileDescription(path, id, flags, position) {\n  this.path = path;\n  this.id = id;\n  this.flags = flags;\n  this.position = position;\n};\n","var Constants = require('./constants.js');\n\nfunction SuperNode(options) {\n  var now = Date.now();\n\n  this.id = Constants.SUPER_NODE_ID;\n  this.mode = Constants.MODE_META;\n  this.atime = options.atime || now;\n  this.ctime = options.ctime || now;\n  this.mtime = options.mtime || now;\n  // root node id (randomly generated)\n  this.rnode = options.rnode;\n}\n\nSuperNode.create = function(options, callback) {\n  options.guid(function(err, rnode) {\n    if(err) {\n      callback(err);\n      return;\n    }\n    options.rnode = options.rnode || rnode;\n    callback(null, new SuperNode(options));\n  });\n};\n\nmodule.exports = SuperNode;\n","var MODE_FILE = require('./constants.js').MODE_FILE;\n\nfunction Node(options) {\n  var now = Date.now();\n\n  this.id = options.id;\n  this.mode = options.mode || MODE_FILE;  // node type (file, directory, etc)\n  this.size = options.size || 0; // size (bytes for files, entries for directories)\n  this.atime = options.atime || now; // access time (will mirror ctime after creation)\n  this.ctime = options.ctime || now; // creation/change time\n  this.mtime = options.mtime || now; // modified time\n  this.flags = options.flags || []; // file flags\n  this.xattrs = options.xattrs || {}; // extended attributes\n  this.nlinks = options.nlinks || 0; // links count\n  this.version = options.version || 0; // node version\n  this.blksize = undefined; // block size\n  this.nblocks = 1; // blocks count\n  this.data = options.data; // id for data object\n}\n\n// Make sure the options object has an id on property,\n// either from caller or one we generate using supplied guid fn.\nfunction ensureID(options, prop, callback) {\n  if(options[prop]) {\n    callback(null);\n  } else {\n    options.guid(function(err, id) {\n      options[prop] = id;\n      callback(err);\n    });\n  }\n}\n\nNode.create = function(options, callback) {\n  // We expect both options.id and options.data to be provided/generated.\n  ensureID(options, 'id', function(err) {\n    if(err) {\n      callback(err);\n      return;\n    }\n\n    ensureID(options, 'data', function(err) {\n      if(err) {\n        callback(err);\n        return;\n      }\n\n      callback(null, new Node(options));\n    });\n  });\n};\n\nmodule.exports = Node;\n","var Constants = require('./constants.js');\n\nfunction Stats(fileNode, devName) {\n  this.node = fileNode.id;\n  this.dev = devName;\n  this.size = fileNode.size;\n  this.nlinks = fileNode.nlinks;\n  this.atime = fileNode.atime;\n  this.mtime = fileNode.mtime;\n  this.ctime = fileNode.ctime;\n  this.type = fileNode.mode;\n}\n\nStats.prototype.isFile = function() {\n  return this.type === Constants.MODE_FILE;\n};\n\nStats.prototype.isDirectory = function() {\n  return this.type === Constants.MODE_DIRECTORY;\n};\n\nStats.prototype.isSymbolicLink = function() {\n  return this.type === Constants.MODE_SYMBOLIC_LINK;\n};\n\n// These will always be false in Filer.\nStats.prototype.isSocket          =\nStats.prototype.isFIFO            =\nStats.prototype.isCharacterDevice =\nStats.prototype.isBlockDevice     =\nfunction() {\n  return false;\n};\n\nmodule.exports = Stats;\n","var _ = require('../../lib/nodash.js');\n\nvar Path = require('../path.js');\nvar normalize = Path.normalize;\nvar dirname = Path.dirname;\nvar basename = Path.basename;\nvar isAbsolutePath = Path.isAbsolute;\nvar isNullPath = Path.isNull;\n\nvar Constants = require('../constants.js');\nvar MODE_FILE = Constants.MODE_FILE;\nvar MODE_DIRECTORY = Constants.MODE_DIRECTORY;\nvar MODE_SYMBOLIC_LINK = Constants.MODE_SYMBOLIC_LINK;\nvar MODE_META = Constants.MODE_META;\n\nvar ROOT_DIRECTORY_NAME = Constants.ROOT_DIRECTORY_NAME;\nvar SUPER_NODE_ID = Constants.SUPER_NODE_ID;\nvar SYMLOOP_MAX = Constants.SYMLOOP_MAX;\n\nvar O_READ = Constants.O_READ;\nvar O_WRITE = Constants.O_WRITE;\nvar O_CREATE = Constants.O_CREATE;\nvar O_EXCLUSIVE = Constants.O_EXCLUSIVE;\nvar O_TRUNCATE = Constants.O_TRUNCATE;\nvar O_APPEND = Constants.O_APPEND;\nvar O_FLAGS = Constants.O_FLAGS;\n\nvar XATTR_CREATE = Constants.XATTR_CREATE;\nvar XATTR_REPLACE = Constants.XATTR_REPLACE;\nvar FS_NOMTIME = Constants.FS_NOMTIME;\nvar FS_NOCTIME = Constants.FS_NOCTIME;\n\nvar Encoding = require('../encoding.js');\nvar Errors = require('../errors.js');\nvar DirectoryEntry = require('../directory-entry.js');\nvar OpenFileDescription = require('../open-file-description.js');\nvar SuperNode = require('../super-node.js');\nvar Node = require('../node.js');\nvar Stats = require('../stats.js');\nvar Buffer = require('../buffer.js');\n\n/**\n * Many functions below use this callback pattern. If it's not\n * re-defined, we use this to generate a callback. NOTE: this\n * can be use for callbacks of both forms without problem (i.e.,\n * since result will be undefined if not returned):\n *  - callback(error)\n *  - callback(error, result)\n */\nfunction standard_check_result_cb(callback) {\n  return function(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, result);\n    }\n  };\n}\n\n/**\n * Update node times. Only passed times are modified (undefined times are ignored)\n * and filesystem flags are examined in order to override update logic.\n */\nfunction update_node_times(context, path, node, times, callback) {\n  // Honour mount flags for how we update times\n  var flags = context.flags;\n  if(_(flags).contains(FS_NOCTIME)) {\n    delete times.ctime;\n  }\n  if(_(flags).contains(FS_NOMTIME)) {\n    delete times.mtime;\n  }\n\n  // Only do the update if required (i.e., times are still present)\n  var update = false;\n  if(times.ctime) {\n    node.ctime = times.ctime;\n    // We don't do atime tracking for perf reasons, but do mirror ctime\n    node.atime = times.ctime;\n    update = true;\n  }\n  if(times.atime) {\n    // The only time we explicitly pass atime is when utimes(), futimes() is called.\n    // Override ctime mirror here if so\n    node.atime = times.atime;\n    update = true;\n  }\n  if(times.mtime) {\n    node.mtime = times.mtime;\n    update = true;\n  }\n\n  function complete(error) {\n    // Queue this change so we can send watch events.\n    // Unlike node.js, we send the full path vs. basename/dirname only.\n    context.changes.push({ event: 'change', path: path });\n    callback(error);\n  }\n\n  if(update) {\n    context.putObject(node.id, node, complete);\n  } else {\n    complete();\n  }\n}\n\n/**\n * make_node()\n */\n// in: file or directory path\n// out: new node representing file/directory\nfunction make_node(context, path, mode, callback) {\n  if(mode !== MODE_DIRECTORY && mode !== MODE_FILE) {\n    return callback(new Errors.EINVAL('mode must be a directory or file', path));\n  }\n\n  path = normalize(path);\n\n  var name = basename(path);\n  var parentPath = dirname(path);\n  var parentNode;\n  var parentNodeData;\n  var node;\n\n  // Check if the parent node exists\n  function create_node_in_parent(error, parentDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(parentDirectoryNode.mode !== MODE_DIRECTORY) {\n      callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));\n    } else {\n      parentNode = parentDirectoryNode;\n      find_node(context, path, check_if_node_exists);\n    }\n  }\n\n  // Check if the node to be created already exists\n  function check_if_node_exists(error, result) {\n    if(!error && result) {\n      callback(new Errors.EEXIST('path name already exists', path));\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      context.getObject(parentNode.data, create_node);\n    }\n  }\n\n  // Create the new node\n  function create_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentNodeData = result;\n      Node.create({guid: context.guid, mode: mode}, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        node = result;\n        node.nlinks += 1;\n        context.putObject(node.id, node, update_parent_node_data);\n      });\n    }\n  }\n\n  // Update parent node time\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, node, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  // Update the parent nodes data\n  function update_parent_node_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      parentNodeData[name] = new DirectoryEntry(node.id, mode);\n      context.putObject(parentNode.data, parentNodeData, update_time);\n    }\n  }\n\n  // Find the parent node\n  find_node(context, parentPath, create_node_in_parent);\n}\n\n/**\n * find_node\n */\n// in: file or directory path\n// out: node structure, or error\nfunction find_node(context, path, callback) {\n  path = normalize(path);\n  if(!path) {\n    return callback(new Errors.ENOENT('path is an empty string'));\n  }\n  var name = basename(path);\n  var parentPath = dirname(path);\n  var followedCount = 0;\n\n  function read_root_directory_node(error, superNode) {\n    if(error) {\n      callback(error);\n    } else if(!superNode || superNode.mode !== MODE_META || !superNode.rnode) {\n      callback(new Errors.EFILESYSTEMERROR());\n    } else {\n      context.getObject(superNode.rnode, check_root_directory_node);\n    }\n  }\n\n  function check_root_directory_node(error, rootDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(!rootDirectoryNode) {\n      callback(new Errors.ENOENT());\n    } else {\n      callback(null, rootDirectoryNode);\n    }\n  }\n\n  // in: parent directory node\n  // out: parent directory data\n  function read_parent_directory_data(error, parentDirectoryNode) {\n    if(error) {\n      callback(error);\n    } else if(parentDirectoryNode.mode !== MODE_DIRECTORY || !parentDirectoryNode.data) {\n      callback(new Errors.ENOTDIR('a component of the path prefix is not a directory', path));\n    } else {\n      context.getObject(parentDirectoryNode.data, get_node_from_parent_directory_data);\n    }\n  }\n\n  // in: parent directory data\n  // out: searched node\n  function get_node_from_parent_directory_data(error, parentDirectoryData) {\n    if(error) {\n      callback(error);\n    } else {\n      if(!_(parentDirectoryData).has(name)) {\n        callback(new Errors.ENOENT(null, path));\n      } else {\n        var nodeId = parentDirectoryData[name].id;\n        context.getObject(nodeId, is_symbolic_link);\n      }\n    }\n  }\n\n  function is_symbolic_link(error, node) {\n    if(error) {\n      callback(error);\n    } else {\n      if(node.mode == MODE_SYMBOLIC_LINK) {\n        followedCount++;\n        if(followedCount > SYMLOOP_MAX){\n          callback(new Errors.ELOOP(null, path));\n        } else {\n          follow_symbolic_link(node.data);\n        }\n      } else {\n        callback(null, node);\n      }\n    }\n  }\n\n  function follow_symbolic_link(data) {\n    data = normalize(data);\n    parentPath = dirname(data);\n    name = basename(data);\n    if(ROOT_DIRECTORY_NAME == name) {\n      context.getObject(SUPER_NODE_ID, read_root_directory_node);\n    } else {\n      find_node(context, parentPath, read_parent_directory_data);\n    }\n  }\n\n  if(ROOT_DIRECTORY_NAME == name) {\n    context.getObject(SUPER_NODE_ID, read_root_directory_node);\n  } else {\n    find_node(context, parentPath, read_parent_directory_data);\n  }\n}\n\n\n/**\n * set extended attribute (refactor)\n */\nfunction set_extended_attribute (context, path_or_fd, name, value, flag, callback) {\n  var path;\n\n  function set_xattr (error, node) {\n    var xattr = (node ? node.xattrs[name] : null);\n\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    if (error) {\n      callback(error);\n    }\n    else if (flag === XATTR_CREATE && node.xattrs.hasOwnProperty(name)) {\n      callback(new Errors.EEXIST('attribute already exists', path_or_fd));\n    }\n    else if (flag === XATTR_REPLACE && !node.xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR(null, path_or_fd));\n    }\n    else {\n      node.xattrs[name] = value;\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof path_or_fd == 'string') {\n    path = path_or_fd;\n    find_node(context, path_or_fd, set_xattr);\n  }\n  else if (typeof path_or_fd == 'object' && typeof path_or_fd.id == 'string') {\n    path = path_or_fd.path;\n    context.getObject(path_or_fd.id, set_xattr);\n  }\n  else {\n    callback(new Errors.EINVAL('path or file descriptor of wrong type', path_or_fd));\n  }\n}\n\n/**\n * ensure_root_directory. Creates a root node if necessary.\n *\n * Note: this should only be invoked when formatting a new file system.\n * Multiple invocations of this by separate instances will still result\n * in only a single super node.\n */\nfunction ensure_root_directory(context, callback) {\n  var superNode;\n  var directoryNode;\n  var directoryData;\n\n  function ensure_super_node(error, existingNode) {\n    if(!error && existingNode) {\n      // Another instance has beat us and already created the super node.\n      callback();\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      SuperNode.create({guid: context.guid}, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        superNode = result;\n        context.putObject(superNode.id, superNode, write_directory_node);\n      });\n    }\n  }\n\n  function write_directory_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      Node.create({guid: context.guid, id: superNode.rnode, mode: MODE_DIRECTORY}, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        directoryNode = result;\n        directoryNode.nlinks += 1;\n        context.putObject(directoryNode.id, directoryNode, write_directory_data);\n      });\n    }\n  }\n\n  function write_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = {};\n      context.putObject(directoryNode.data, directoryData, callback);\n    }\n  }\n\n  context.getObject(SUPER_NODE_ID, ensure_super_node);\n}\n\n/**\n * make_directory\n */\nfunction make_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var parentDirectoryNode;\n  var parentDirectoryData;\n\n  function check_if_directory_exists(error, result) {\n    if(!error && result) {\n      callback(new Errors.EEXIST(null, path));\n    } else if(error && !(error instanceof Errors.ENOENT)) {\n      callback(error);\n    } else {\n      find_node(context, parentPath, read_parent_directory_data);\n    }\n  }\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryNode = result;\n      context.getObject(parentDirectoryNode.data, write_directory_node);\n    }\n  }\n\n  function write_directory_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryData = result;\n      Node.create({guid: context.guid, mode: MODE_DIRECTORY}, function(error, result) {\n        if(error) {\n          callback(error);\n          return;\n        }\n        directoryNode = result;\n        directoryNode.nlinks += 1;\n        context.putObject(directoryNode.id, directoryNode, write_directory_data);\n      });\n    }\n  }\n\n  function write_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = {};\n      context.putObject(directoryNode.data, directoryData, update_parent_directory_data);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, parentDirectoryNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_parent_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryData[name] = new DirectoryEntry(directoryNode.id, MODE_DIRECTORY);\n      context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);\n    }\n  }\n\n  find_node(context, path, check_if_directory_exists);\n}\n\n/**\n * remove_directory\n */\nfunction remove_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var parentDirectoryNode;\n  var parentDirectoryData;\n\n  function read_parent_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      parentDirectoryNode = result;\n      context.getObject(parentDirectoryNode.data, check_if_node_exists);\n    }\n  }\n\n  function check_if_node_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else if(ROOT_DIRECTORY_NAME == name) {\n      callback(new Errors.EBUSY(null, path));\n    } else if(!_(result).has(name)) {\n      callback(new Errors.ENOENT(null, path));\n    } else {\n      parentDirectoryData = result;\n      directoryNode = parentDirectoryData[name].id;\n      context.getObject(directoryNode, check_if_node_is_directory);\n    }\n  }\n\n  function check_if_node_is_directory(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.mode != MODE_DIRECTORY) {\n      callback(new Errors.ENOTDIR(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_directory_is_empty);\n    }\n  }\n\n  function check_if_directory_is_empty(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(_(directoryData).size() > 0) {\n        callback(new Errors.ENOTEMPTY(null, path));\n      } else {\n        remove_directory_entry_from_parent_directory_node();\n      }\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, parentDirectoryNode, { mtime: now, ctime: now }, remove_directory_node);\n    }\n  }\n\n  function remove_directory_entry_from_parent_directory_node() {\n    delete parentDirectoryData[name];\n    context.putObject(parentDirectoryNode.data, parentDirectoryData, update_time);\n  }\n\n  function remove_directory_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(directoryNode.id, remove_directory_data);\n    }\n  }\n\n  function remove_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(directoryNode.data, callback);\n    }\n  }\n\n  find_node(context, parentPath, read_parent_directory_data);\n}\n\nfunction open_file(context, path, flags, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var directoryEntry;\n  var fileNode;\n  var fileData;\n\n  var followedCount = 0;\n\n  if(ROOT_DIRECTORY_NAME == name) {\n    if(_(flags).contains(O_WRITE)) {\n      callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n    } else {\n      find_node(context, path, set_file_node);\n    }\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.mode !== MODE_DIRECTORY) {\n      callback(new Errors.ENOENT(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(_(directoryData).has(name)) {\n        if(_(flags).contains(O_EXCLUSIVE)) {\n          callback(new Errors.ENOENT('O_CREATE and O_EXCLUSIVE are set, and the named file exists', path));\n        } else {\n          directoryEntry = directoryData[name];\n          if(directoryEntry.type == MODE_DIRECTORY && _(flags).contains(O_WRITE)) {\n            callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n          } else {\n            context.getObject(directoryEntry.id, check_if_symbolic_link);\n          }\n        }\n      } else {\n        if(!_(flags).contains(O_CREATE)) {\n          callback(new Errors.ENOENT('O_CREATE is not set and the named file does not exist', path));\n        } else {\n          write_file_node();\n        }\n      }\n    }\n  }\n\n  function check_if_symbolic_link(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var node = result;\n      if(node.mode == MODE_SYMBOLIC_LINK) {\n        followedCount++;\n        if(followedCount > SYMLOOP_MAX){\n          callback(new Errors.ELOOP(null, path));\n        } else {\n          follow_symbolic_link(node.data);\n        }\n      } else {\n        set_file_node(undefined, node);\n      }\n    }\n  }\n\n  function follow_symbolic_link(data) {\n    data = normalize(data);\n    parentPath = dirname(data);\n    name = basename(data);\n    if(ROOT_DIRECTORY_NAME == name) {\n      if(_(flags).contains(O_WRITE)) {\n        callback(new Errors.EISDIR('the named file is a directory and O_WRITE is set', path));\n      } else {\n        find_node(context, path, set_file_node);\n      }\n    }\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function set_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      callback(null, fileNode);\n    }\n  }\n\n  function write_file_node() {\n    Node.create({guid: context.guid, mode: MODE_FILE}, function(error, result) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      fileNode = result;\n      fileNode.nlinks += 1;\n      context.putObject(fileNode.id, fileNode, write_file_data);\n    });\n  }\n\n  function write_file_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = new Buffer(0);\n      fileData.fill(0);\n      context.putBuffer(fileNode.data, fileData, update_directory_data);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, handle_update_result);\n    }\n  }\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData[name] = new DirectoryEntry(fileNode.id, MODE_FILE);\n      context.putObject(directoryNode.data, directoryData, update_time);\n    }\n  }\n\n  function handle_update_result(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, fileNode);\n    }\n  }\n}\n\nfunction replace_data(context, ofd, buffer, offset, length, callback) {\n  var fileNode;\n\n  function return_nbytes(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, length);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, return_nbytes);\n    }\n  }\n\n  function update_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function write_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      var newData = new Buffer(length);\n      newData.fill(0);\n      buffer.copy(newData, 0, offset, offset + length);\n      ofd.position = length;\n\n      fileNode.size = length;\n      fileNode.version += 1;\n\n      context.putBuffer(fileNode.data, newData, update_file_node);\n    }\n  }\n\n  context.getObject(ofd.id, write_file_data);\n}\n\nfunction write_data(context, ofd, buffer, offset, length, position, callback) {\n  var fileNode;\n  var fileData;\n\n  function return_nbytes(error) {\n    if(error) {\n      callback(error);\n    } else {\n      callback(null, length);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, return_nbytes);\n    }\n  }\n\n  function update_file_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function update_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = result;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var _position = (!(undefined === position || null === position)) ? position : ofd.position;\n      var newSize = Math.max(fileData.length, _position + length);\n      var newData = new Buffer(newSize);\n      newData.fill(0);\n      if(fileData) {\n        fileData.copy(newData);\n      }\n      buffer.copy(newData, _position, offset, offset + length);\n      if(undefined === position) {\n        ofd.position += length;\n      }\n\n      fileNode.size = newSize;\n      fileNode.version += 1;\n\n      context.putBuffer(fileNode.data, newData, update_file_node);\n    }\n  }\n\n  function read_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      context.getBuffer(fileNode.data, update_file_data);\n    }\n  }\n\n  context.getObject(ofd.id, read_file_data);\n}\n\nfunction read_data(context, ofd, buffer, offset, length, position, callback) {\n  var fileNode;\n  var fileData;\n\n  function handle_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileData = result;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var _position = (!(undefined === position || null === position)) ? position : ofd.position;\n      length = (_position + length > buffer.length) ? length - _position : length;\n      fileData.copy(buffer, offset, _position, _position + length);\n      if(undefined === position) {\n        ofd.position += length;\n      }\n      callback(null, length);\n    }\n  }\n\n  function read_file_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      context.getBuffer(fileNode.data, handle_file_data);\n    }\n  }\n\n  context.getObject(ofd.id, read_file_data);\n}\n\nfunction stat_file(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  find_node(context, path, standard_check_result_cb(callback));\n}\n\nfunction fstat_file(context, ofd, callback) {\n  context.getObject(ofd.id, standard_check_result_cb(callback));\n}\n\nfunction lstat_file(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n\n  if(ROOT_DIRECTORY_NAME == name) {\n    find_node(context, path, standard_check_result_cb(callback));\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!_(directoryData).has(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', path));\n      } else {\n        context.getObject(directoryData[name].id, standard_check_result_cb(callback));\n      }\n    }\n  }\n}\n\nfunction link_node(context, oldpath, newpath, callback) {\n  oldpath = normalize(oldpath);\n  var oldname = basename(oldpath);\n  var oldParentPath = dirname(oldpath);\n\n  newpath = normalize(newpath);\n  var newname = basename(newpath);\n  var newParentPath = dirname(newpath);\n\n  var oldDirectoryNode;\n  var oldDirectoryData;\n  var newDirectoryNode;\n  var newDirectoryData;\n  var fileNode;\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      update_node_times(context, newpath,  fileNode, { ctime: Date.now() }, callback);\n    }\n  }\n\n  function update_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      fileNode.nlinks += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  function read_directory_entry(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      context.getObject(newDirectoryData[newname].id, update_file_node);\n    }\n  }\n\n  function check_if_new_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newDirectoryData = result;\n      if(_(newDirectoryData).has(newname)) {\n        callback(new Errors.EEXIST('newpath resolves to an existing file', newname));\n      } else {\n        newDirectoryData[newname] = oldDirectoryData[oldname];\n        context.putObject(newDirectoryNode.data, newDirectoryData, read_directory_entry);\n      }\n    }\n  }\n\n  function read_new_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      newDirectoryNode = result;\n      context.getObject(newDirectoryNode.data, check_if_new_file_exists);\n    }\n  }\n\n  function check_if_old_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldDirectoryData = result;\n      if(!_(oldDirectoryData).has(oldname)) {\n        callback(new Errors.ENOENT('a component of either path prefix does not exist', oldname));\n      } else {\n        find_node(context, newParentPath, read_new_directory_data);\n      }\n    }\n  }\n\n  function read_old_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      oldDirectoryNode = result;\n      context.getObject(oldDirectoryNode.data, check_if_old_file_exists);\n    }\n  }\n\n  find_node(context, oldParentPath, read_old_directory_data);\n}\n\nfunction unlink_node(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n  var fileNode;\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      delete directoryData[name];\n      context.putObject(directoryNode.data, directoryData, function(error) {\n        var now = Date.now();\n        update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, callback);\n      });\n    }\n  }\n\n  function delete_file_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      context.delete(fileNode.data, update_directory_data);\n    }\n  }\n\n  function update_file_node(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode = result;\n      fileNode.nlinks -= 1;\n      if(fileNode.nlinks < 1) {\n        context.delete(fileNode.id, delete_file_data);\n      } else {\n        context.putObject(fileNode.id, fileNode, function(error) {\n          update_node_times(context, path, fileNode, { ctime: Date.now() }, update_directory_data);\n        });\n      }\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!_(directoryData).has(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', name));\n      } else {\n        context.getObject(directoryData[name].id, update_file_node);\n      }\n    }\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  find_node(context, parentPath, read_directory_data);\n}\n\nfunction read_directory(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n\n  var directoryNode;\n  var directoryData;\n\n  function handle_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      var files = Object.keys(directoryData);\n      callback(null, files);\n    }\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else if(result.mode !== MODE_DIRECTORY) {\n      callback(new Errors.ENOTDIR(null, path));\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, handle_directory_data);\n    }\n  }\n\n  find_node(context, path, read_directory_data);\n}\n\nfunction make_symbolic_link(context, srcpath, dstpath, callback) {\n  dstpath = normalize(dstpath);\n  var name = basename(dstpath);\n  var parentPath = dirname(dstpath);\n\n  var directoryNode;\n  var directoryData;\n  var fileNode;\n\n  if(ROOT_DIRECTORY_NAME == name) {\n    callback(new Errors.EEXIST(null, name));\n  } else {\n    find_node(context, parentPath, read_directory_data);\n  }\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(_(directoryData).has(name)) {\n        callback(new Errors.EEXIST(null, name));\n      } else {\n        write_file_node();\n      }\n    }\n  }\n\n  function write_file_node() {\n    Node.create({guid: context.guid, mode: MODE_SYMBOLIC_LINK}, function(error, result) {\n      if(error) {\n        callback(error);\n        return;\n      }\n      fileNode = result;\n      fileNode.nlinks += 1;\n      fileNode.size = srcpath.length;\n      fileNode.data = srcpath;\n      context.putObject(fileNode.id, fileNode, update_directory_data);\n    });\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, parentPath, directoryNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_directory_data(error) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData[name] = new DirectoryEntry(fileNode.id, MODE_SYMBOLIC_LINK);\n      context.putObject(directoryNode.data, directoryData, update_time);\n    }\n  }\n}\n\nfunction read_link(context, path, callback) {\n  path = normalize(path);\n  var name = basename(path);\n  var parentPath = dirname(path);\n\n  var directoryNode;\n  var directoryData;\n\n  find_node(context, parentPath, read_directory_data);\n\n  function read_directory_data(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryNode = result;\n      context.getObject(directoryNode.data, check_if_file_exists);\n    }\n  }\n\n  function check_if_file_exists(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      directoryData = result;\n      if(!_(directoryData).has(name)) {\n        callback(new Errors.ENOENT('a component of the path does not name an existing file', name));\n      } else {\n        context.getObject(directoryData[name].id, check_if_symbolic);\n      }\n    }\n  }\n\n  function check_if_symbolic(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      if(result.mode != MODE_SYMBOLIC_LINK) {\n        callback(new Errors.EINVAL('path not a symbolic link', path));\n      } else {\n        callback(null, result.data);\n      }\n    }\n  }\n}\n\nfunction truncate_file(context, path, length, callback) {\n  path = normalize(path);\n\n  var fileNode;\n\n  function read_file_data (error, node) {\n    if (error) {\n      callback(error);\n    } else if(node.mode == MODE_DIRECTORY ) {\n      callback(new Errors.EISDIR(null, path));\n    } else{\n      fileNode = node;\n      context.getBuffer(fileNode.data, truncate_file_data);\n    }\n  }\n\n  function truncate_file_data(error, fileData) {\n    if (error) {\n      callback(error);\n    } else {\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      var data = new Buffer(length);\n      data.fill(0);\n      if(fileData) {\n        fileData.copy(data);\n      }\n      context.putBuffer(fileNode.data, data, update_file_node);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, path, fileNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_file_node (error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode.size = length;\n      fileNode.version += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  if(length < 0) {\n    callback(new Errors.EINVAL('length cannot be negative'));\n  } else {\n    find_node(context, path, read_file_data);\n  }\n}\n\nfunction ftruncate_file(context, ofd, length, callback) {\n  var fileNode;\n\n  function read_file_data (error, node) {\n    if (error) {\n      callback(error);\n    } else if(node.mode == MODE_DIRECTORY ) {\n      callback(new Errors.EISDIR());\n    } else{\n      fileNode = node;\n      context.getBuffer(fileNode.data, truncate_file_data);\n    }\n  }\n\n  function truncate_file_data(error, fileData) {\n    if (error) {\n      callback(error);\n    } else {\n      var data;\n      if(!fileData) {\n        return callback(new Errors.EIO('Expected Buffer'));\n      }\n      if(fileData) {\n        data = fileData.slice(0, length);\n      } else {\n        data = new Buffer(length);\n        data.fill(0);\n      }\n      context.putBuffer(fileNode.data, data, update_file_node);\n    }\n  }\n\n  function update_time(error) {\n    if(error) {\n      callback(error);\n    } else {\n      var now = Date.now();\n      update_node_times(context, ofd.path, fileNode, { mtime: now, ctime: now }, callback);\n    }\n  }\n\n  function update_file_node (error) {\n    if(error) {\n      callback(error);\n    } else {\n      fileNode.size = length;\n      fileNode.version += 1;\n      context.putObject(fileNode.id, fileNode, update_time);\n    }\n  }\n\n  if(length < 0) {\n    callback(new Errors.EINVAL('length cannot be negative'));\n  } else {\n    context.getObject(ofd.id, read_file_data);\n  }\n}\n\nfunction utimes_file(context, path, atime, mtime, callback) {\n  path = normalize(path);\n\n  function update_times(error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      update_node_times(context, path, node, { atime: atime, ctime: mtime, mtime: mtime }, callback);\n    }\n  }\n\n  if (typeof atime != 'number' || typeof mtime != 'number') {\n    callback(new Errors.EINVAL('atime and mtime must be number', path));\n  }\n  else if (atime < 0 || mtime < 0) {\n    callback(new Errors.EINVAL('atime and mtime must be positive integers', path));\n  }\n  else {\n    find_node(context, path, update_times);\n  }\n}\n\nfunction futimes_file(context, ofd, atime, mtime, callback) {\n\n  function update_times (error, node) {\n    if (error) {\n      callback(error);\n    } else {\n      update_node_times(context, ofd.path, node, { atime: atime, ctime: mtime, mtime: mtime }, callback);\n    }\n  }\n\n  if (typeof atime != 'number' || typeof mtime != 'number') {\n    callback(new Errors.EINVAL('atime and mtime must be a number'));\n  }\n  else if (atime < 0 || mtime < 0) {\n    callback(new Errors.EINVAL('atime and mtime must be positive integers'));\n  }\n  else {\n    context.getObject(ofd.id, update_times);\n  }\n}\n\nfunction setxattr_file(context, path, name, value, flag, callback) {\n  path = normalize(path);\n\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else if (flag !== null &&\n           flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {\n    callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE', path));\n  }\n  else {\n    set_extended_attribute(context, path, name, value, flag, callback);\n  }\n}\n\nfunction fsetxattr_file (context, ofd, name, value, flag, callback) {\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string'));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else if (flag !== null &&\n           flag !== XATTR_CREATE && flag !== XATTR_REPLACE) {\n    callback(new Errors.EINVAL('invalid flag, must be null, XATTR_CREATE or XATTR_REPLACE'));\n  }\n  else {\n    set_extended_attribute(context, ofd, name, value, flag, callback);\n  }\n}\n\nfunction getxattr_file (context, path, name, callback) {\n  path = normalize(path);\n\n  function get_xattr(error, node) {\n    var xattr = (node ? node.xattrs[name] : null);\n\n    if (error) {\n      callback (error);\n    }\n    else if (!node.xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR(null, path));\n    }\n    else {\n      callback(null, node.xattrs[name]);\n    }\n  }\n\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else {\n    find_node(context, path, get_xattr);\n  }\n}\n\nfunction fgetxattr_file (context, ofd, name, callback) {\n\n  function get_xattr (error, node) {\n    var xattr = (node ? node.xattrs[name] : null);\n\n    if (error) {\n      callback(error);\n    }\n    else if (!node.xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR());\n    }\n    else {\n      callback(null, node.xattrs[name]);\n    }\n  }\n\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL());\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else {\n    context.getObject(ofd.id, get_xattr);\n  }\n}\n\nfunction removexattr_file (context, path, name, callback) {\n  path = normalize(path);\n\n  function remove_xattr (error, node) {\n    var xattr = (node ? node.xattrs : null);\n\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    if (error) {\n      callback(error);\n    }\n    else if (!xattr.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR(null, path));\n    }\n    else {\n      delete node.xattrs[name];\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string', path));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string', path));\n  }\n  else {\n    find_node(context, path, remove_xattr);\n  }\n}\n\nfunction fremovexattr_file (context, ofd, name, callback) {\n\n  function remove_xattr (error, node) {\n    function update_time(error) {\n      if(error) {\n        callback(error);\n      } else {\n        update_node_times(context, ofd.path, node, { ctime: Date.now() }, callback);\n      }\n    }\n\n    if (error) {\n      callback(error);\n    }\n    else if (!node.xattrs.hasOwnProperty(name)) {\n      callback(new Errors.ENOATTR());\n    }\n    else {\n      delete node.xattrs[name];\n      context.putObject(node.id, node, update_time);\n    }\n  }\n\n  if (typeof name != 'string') {\n    callback(new Errors.EINVAL('attribute name must be a string'));\n  }\n  else if (!name) {\n    callback(new Errors.EINVAL('attribute name cannot be an empty string'));\n  }\n  else {\n    context.getObject(ofd.id, remove_xattr);\n  }\n}\n\nfunction validate_flags(flags) {\n  if(!_(O_FLAGS).has(flags)) {\n    return null;\n  }\n  return O_FLAGS[flags];\n}\n\nfunction validate_file_options(options, enc, fileMode){\n  if(!options) {\n    options = { encoding: enc, flag: fileMode };\n  } else if(typeof options === \"function\") {\n    options = { encoding: enc, flag: fileMode };\n  } else if(typeof options === \"string\") {\n    options = { encoding: options, flag: fileMode };\n  }\n  return options;\n}\n\nfunction pathCheck(path, callback) {\n  var err;\n\n  if(!path) {\n    err = new Errors.EINVAL('Path must be a string', path);\n  } else if(isNullPath(path)) {\n    err = new Errors.EINVAL('Path must be a string without null bytes.', path);\n  } else if(!isAbsolutePath(path)) {\n    err = new Errors.EINVAL('Path must be absolute.', path);\n  }\n\n  if(err) {\n    callback(err);\n    return false;\n  }\n  return true;\n}\n\n\nfunction open(fs, context, path, flags, mode, callback) {\n  // NOTE: we support the same signature as node with a `mode` arg,\n  // but ignore it.\n  callback = arguments[arguments.length - 1];\n  if(!pathCheck(path, callback)) return;\n\n  function check_result(error, fileNode) {\n    if(error) {\n      callback(error);\n    } else {\n      var position;\n      if(_(flags).contains(O_APPEND)) {\n        position = fileNode.size;\n      } else {\n        position = 0;\n      }\n      var openFileDescription = new OpenFileDescription(path, fileNode.id, flags, position);\n      var fd = fs.allocDescriptor(openFileDescription);\n      callback(null, fd);\n    }\n  }\n\n  flags = validate_flags(flags);\n  if(!flags) {\n    callback(new Errors.EINVAL('flags is not valid'), path);\n  }\n\n  open_file(context, path, flags, check_result);\n}\n\nfunction close(fs, context, fd, callback) {\n  if(!_(fs.openFiles).has(fd)) {\n    callback(new Errors.EBADF());\n  } else {\n    fs.releaseDescriptor(fd);\n    callback(null);\n  }\n}\n\nfunction mknod(fs, context, path, mode, callback) {\n  if(!pathCheck(path, callback)) return;\n  make_node(context, path, mode, callback);\n}\n\nfunction mkdir(fs, context, path, mode, callback) {\n  // NOTE: we support passing a mode arg, but we ignore it internally for now.\n  callback = arguments[arguments.length - 1];\n  if(!pathCheck(path, callback)) return;\n  make_directory(context, path, standard_check_result_cb(callback));\n}\n\nfunction rmdir(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  remove_directory(context, path, standard_check_result_cb(callback));\n}\n\nfunction stat(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(result, fs.name);\n      callback(null, stats);\n    }\n  }\n\n  stat_file(context, path, check_result);\n}\n\nfunction fstat(fs, context, fd, callback) {\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(result, fs.name);\n      callback(null, stats);\n    }\n  }\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else {\n    fstat_file(context, ofd, check_result);\n  }\n}\n\nfunction link(fs, context, oldpath, newpath, callback) {\n  if(!pathCheck(oldpath, callback)) return;\n  if(!pathCheck(newpath, callback)) return;\n  link_node(context, oldpath, newpath, standard_check_result_cb(callback));\n}\n\nfunction unlink(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  unlink_node(context, path, standard_check_result_cb(callback));\n}\n\nfunction read(fs, context, fd, buffer, offset, length, position, callback) {\n  // Follow how node.js does this\n  function wrapped_cb(err, bytesRead) {\n    // Retain a reference to buffer so that it can't be GC'ed too soon.\n    callback(err, bytesRead || 0, buffer);\n  }\n\n  offset = (undefined === offset) ? 0 : offset;\n  length = (undefined === length) ? buffer.length - offset : length;\n  callback = arguments[arguments.length - 1];\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!_(ofd.flags).contains(O_READ)) {\n    callback(new Errors.EBADF('descriptor does not permit reading'));\n  } else {\n    read_data(context, ofd, buffer, offset, length, position, standard_check_result_cb(wrapped_cb));\n  }\n}\n\nfunction readFile(fs, context, path, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, null, 'r');\n\n  if(!pathCheck(path, callback)) return;\n\n  var flags = validate_flags(options.flag || 'r');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);\n    var fd = fs.allocDescriptor(ofd);\n\n    function cleanup() {\n      fs.releaseDescriptor(fd);\n    }\n\n    fstat_file(context, ofd, function(err, fstatResult) {\n      if(err) {\n        cleanup();\n        return callback(err);\n      }\n\n      var stats = new Stats(fstatResult, fs.name);\n\n      if(stats.isDirectory()) {\n        cleanup();\n        return callback(new Errors.EISDIR('illegal operation on directory', path));\n      }\n\n      var size = stats.size;\n      var buffer = new Buffer(size);\n      buffer.fill(0);\n\n      read_data(context, ofd, buffer, 0, size, 0, function(err, nbytes) {\n        cleanup();\n\n        if(err) {\n          return callback(err);\n        }\n\n        var data;\n        if(options.encoding === 'utf8') {\n          data = Encoding.decode(buffer);\n        } else {\n          data = buffer;\n        }\n        callback(null, data);\n      });\n    });\n  });\n}\n\nfunction write(fs, context, fd, buffer, offset, length, position, callback) {\n  callback = arguments[arguments.length - 1];\n  offset = (undefined === offset) ? 0 : offset;\n  length = (undefined === length) ? buffer.length - offset : length;\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!_(ofd.flags).contains(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else if(buffer.length - offset < length) {\n    callback(new Errors.EIO('intput buffer is too small'));\n  } else {\n    write_data(context, ofd, buffer, offset, length, position, standard_check_result_cb(callback));\n  }\n}\n\nfunction writeFile(fs, context, path, data, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, 'utf8', 'w');\n\n  if(!pathCheck(path, callback)) return;\n\n  var flags = validate_flags(options.flag || 'w');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  data = data || '';\n  if(typeof data === \"number\") {\n    data = '' + data;\n  }\n  if(typeof data === \"string\" && options.encoding === 'utf8') {\n    data = Encoding.encode(data);\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, 0);\n    var fd = fs.allocDescriptor(ofd);\n\n    replace_data(context, ofd, data, 0, data.length, function(err, nbytes) {\n      fs.releaseDescriptor(fd);\n\n      if(err) {\n        return callback(err);\n      }\n      callback(null);\n    });\n  });\n}\n\nfunction appendFile(fs, context, path, data, options, callback) {\n  callback = arguments[arguments.length - 1];\n  options = validate_file_options(options, 'utf8', 'a');\n\n  if(!pathCheck(path, callback)) return;\n\n  var flags = validate_flags(options.flag || 'a');\n  if(!flags) {\n    return callback(new Errors.EINVAL('flags is not valid', path));\n  }\n\n  data = data || '';\n  if(typeof data === \"number\") {\n    data = '' + data;\n  }\n  if(typeof data === \"string\" && options.encoding === 'utf8') {\n    data = Encoding.encode(data);\n  }\n\n  open_file(context, path, flags, function(err, fileNode) {\n    if(err) {\n      return callback(err);\n    }\n    var ofd = new OpenFileDescription(path, fileNode.id, flags, fileNode.size);\n    var fd = fs.allocDescriptor(ofd);\n\n    write_data(context, ofd, data, 0, data.length, ofd.position, function(err, nbytes) {\n      fs.releaseDescriptor(fd);\n\n      if(err) {\n        return callback(err);\n      }\n      callback(null);\n    });\n  });\n}\n\nfunction exists(fs, context, path, callback) {\n  function cb(err, stats) {\n    callback(err ? false : true);\n  }\n  stat(fs, context, path, cb);\n}\n\nfunction getxattr(fs, context, path, name, callback) {\n  if (!pathCheck(path, callback)) return;\n  getxattr_file(context, path, name, standard_check_result_cb(callback));\n}\n\nfunction fgetxattr(fs, context, fd, name, callback) {\n  var ofd = fs.openFiles[fd];\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else {\n    fgetxattr_file(context, ofd, name, standard_check_result_cb(callback));\n  }\n}\n\nfunction setxattr(fs, context, path, name, value, flag, callback) {\n  if(typeof flag === 'function') {\n    callback = flag;\n    flag = null;\n  }\n\n  if (!pathCheck(path, callback)) return;\n  setxattr_file(context, path, name, value, flag, standard_check_result_cb(callback));\n}\n\nfunction fsetxattr(fs, context, fd, name, value, flag, callback) {\n  if(typeof flag === 'function') {\n    callback = flag;\n    flag = null;\n  }\n\n  var ofd = fs.openFiles[fd];\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else if (!_(ofd.flags).contains(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  }\n  else {\n    fsetxattr_file(context, ofd, name, value, flag, standard_check_result_cb(callback));\n  }\n}\n\nfunction removexattr(fs, context, path, name, callback) {\n  if (!pathCheck(path, callback)) return;\n  removexattr_file(context, path, name, standard_check_result_cb(callback));\n}\n\nfunction fremovexattr(fs, context, fd, name, callback) {\n  var ofd = fs.openFiles[fd];\n  if (!ofd) {\n    callback(new Errors.EBADF());\n  }\n  else if (!_(ofd.flags).contains(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  }\n  else {\n    fremovexattr_file(context, ofd, name, standard_check_result_cb(callback));\n  }\n}\n\nfunction lseek(fs, context, fd, offset, whence, callback) {\n  function update_descriptor_position(error, stats) {\n    if(error) {\n      callback(error);\n    } else {\n      if(stats.size + offset < 0) {\n        callback(new Errors.EINVAL('resulting file offset would be negative'));\n      } else {\n        ofd.position = stats.size + offset;\n        callback(null, ofd.position);\n      }\n    }\n  }\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  }\n\n  if('SET' === whence) {\n    if(offset < 0) {\n      callback(new Errors.EINVAL('resulting file offset would be negative'));\n    } else {\n      ofd.position = offset;\n      callback(null, ofd.position);\n    }\n  } else if('CUR' === whence) {\n    if(ofd.position + offset < 0) {\n      callback(new Errors.EINVAL('resulting file offset would be negative'));\n    } else {\n      ofd.position += offset;\n      callback(null, ofd.position);\n    }\n  } else if('END' === whence) {\n    fstat_file(context, ofd, update_descriptor_position);\n  } else {\n    callback(new Errors.EINVAL('whence argument is not a proper value'));\n  }\n}\n\nfunction readdir(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  read_directory(context, path, standard_check_result_cb(callback));\n}\n\nfunction utimes(fs, context, path, atime, mtime, callback) {\n  if(!pathCheck(path, callback)) return;\n\n  var currentTime = Date.now();\n  atime = (atime) ? atime : currentTime;\n  mtime = (mtime) ? mtime : currentTime;\n\n  utimes_file(context, path, atime, mtime, standard_check_result_cb(callback));\n}\n\nfunction futimes(fs, context, fd, atime, mtime, callback) {\n  var currentTime = Date.now();\n  atime = (atime) ? atime : currentTime;\n  mtime = (mtime) ? mtime : currentTime;\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!_(ofd.flags).contains(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    futimes_file(context, ofd, atime, mtime, standard_check_result_cb(callback));\n  }\n}\n\nfunction rename(fs, context, oldpath, newpath, callback) {\n  if(!pathCheck(oldpath, callback)) return;\n  if(!pathCheck(newpath, callback)) return;\n\n  function unlink_old_node(error) {\n    if(error) {\n      callback(error);\n    } else {\n      unlink_node(context, oldpath, standard_check_result_cb(callback));\n    }\n  }\n\n  link_node(context, oldpath, newpath, unlink_old_node);\n}\n\nfunction symlink(fs, context, srcpath, dstpath, type, callback) {\n  // NOTE: we support passing the `type` arg, but ignore it.\n  callback = arguments[arguments.length - 1];\n  if(!pathCheck(srcpath, callback)) return;\n  if(!pathCheck(dstpath, callback)) return;\n  make_symbolic_link(context, srcpath, dstpath, standard_check_result_cb(callback));\n}\n\nfunction readlink(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n  read_link(context, path, standard_check_result_cb(callback));\n}\n\nfunction lstat(fs, context, path, callback) {\n  if(!pathCheck(path, callback)) return;\n\n  function check_result(error, result) {\n    if(error) {\n      callback(error);\n    } else {\n      var stats = new Stats(result, fs.name);\n      callback(null, stats);\n    }\n  }\n\n  lstat_file(context, path, check_result);\n}\n\nfunction truncate(fs, context, path, length, callback) {\n  // NOTE: length is optional\n  callback = arguments[arguments.length - 1];\n  length = length || 0;\n\n  if(!pathCheck(path, callback)) return;\n  truncate_file(context, path, length, standard_check_result_cb(callback));\n}\n\nfunction ftruncate(fs, context, fd, length, callback) {\n  // NOTE: length is optional\n  callback = arguments[arguments.length - 1];\n  length = length || 0;\n\n  var ofd = fs.openFiles[fd];\n  if(!ofd) {\n    callback(new Errors.EBADF());\n  } else if(!_(ofd.flags).contains(O_WRITE)) {\n    callback(new Errors.EBADF('descriptor does not permit writing'));\n  } else {\n    ftruncate_file(context, ofd, length, standard_check_result_cb(callback));\n  }\n}\n\nmodule.exports = {\n  ensureRootDirectory: ensure_root_directory,\n  open: open,\n  close: close,\n  mknod: mknod,\n  mkdir: mkdir,\n  rmdir: rmdir,\n  unlink: unlink,\n  stat: stat,\n  fstat: fstat,\n  link: link,\n  read: read,\n  readFile: readFile,\n  write: write,\n  writeFile: writeFile,\n  appendFile: appendFile,\n  exists: exists,\n  getxattr: getxattr,\n  fgetxattr: fgetxattr,\n  setxattr: setxattr,\n  fsetxattr: fsetxattr,\n  removexattr: removexattr,\n  fremovexattr: fremovexattr,\n  lseek: lseek,\n  readdir: readdir,\n  utimes: utimes,\n  futimes: futimes,\n  rename: rename,\n  symlink: symlink,\n  readlink: readlink,\n  lstat: lstat,\n  truncate: truncate,\n  ftruncate: ftruncate\n};\n","var _ = require('../../lib/nodash.js');\n\nvar isNullPath = require('../path.js').isNull;\nvar nop = require('../shared.js').nop;\n\nvar Constants = require('../constants.js');\nvar FILE_SYSTEM_NAME = Constants.FILE_SYSTEM_NAME;\nvar FS_FORMAT = Constants.FS_FORMAT;\nvar FS_READY = Constants.FS_READY;\nvar FS_PENDING = Constants.FS_PENDING;\nvar FS_ERROR = Constants.FS_ERROR;\nvar FS_NODUPEIDCHECK = Constants.FS_NODUPEIDCHECK;\n\nvar providers = require('../providers/index.js');\n\nvar Shell = require('../shell/shell.js');\nvar Intercom = require('../../lib/intercom.js');\nvar FSWatcher = require('../fs-watcher.js');\nvar Errors = require('../errors.js');\nvar defaultGuidFn = require('../shared.js').guid;\n\nvar STDIN = Constants.STDIN;\nvar STDOUT = Constants.STDOUT;\nvar STDERR = Constants.STDERR;\nvar FIRST_DESCRIPTOR = Constants.FIRST_DESCRIPTOR;\n\n// The core fs operations live on impl\nvar impl = require('./implementation.js');\n\n// node.js supports a calling pattern that leaves off a callback.\nfunction maybeCallback(callback) {\n  if(typeof callback === \"function\") {\n    return callback;\n  }\n  return function(err) {\n    if(err) {\n      throw err;\n    }\n  };\n}\n\n/**\n * FileSystem\n *\n * A FileSystem takes an `options` object, which can specify a number of,\n * options.  All options are optional, and include:\n *\n * name: the name of the file system, defaults to \"local\"\n *\n * flags: one or more flags to use when creating/opening the file system.\n *        For example: \"FORMAT\" will cause the file system to be formatted.\n *        No explicit flags are set by default.\n *\n * provider: an explicit storage provider to use for the file\n *           system's database context provider.  A number of context\n *           providers are included (see /src/providers), and users\n *           can write one of their own and pass it in to be used.\n *           By default an IndexedDB provider is used.\n *\n * guid: a function for generating unique IDs for nodes in the filesystem.\n *       Use this to override the built-in UUID generation. (Used mainly for tests).\n *\n * callback: a callback function to be executed when the file system becomes\n *           ready for use. Depending on the context provider used, this might\n *           be right away, or could take some time. The callback should expect\n *           an `error` argument, which will be null if everything worked.  Also\n *           users should check the file system's `readyState` and `error`\n *           properties to make sure it is usable.\n */\nfunction FileSystem(options, callback) {\n  options = options || {};\n  callback = callback || nop;\n\n  var flags = options.flags;\n  var guid = options.guid ? options.guid : defaultGuidFn;\n  var provider = options.provider || new providers.Default(options.name || FILE_SYSTEM_NAME);\n  // If we're given a provider, match its name unless we get an explicit name\n  var name = options.name || provider.name;\n  var forceFormatting = _(flags).contains(FS_FORMAT);\n\n  var fs = this;\n  fs.readyState = FS_PENDING;\n  fs.name = name;\n  fs.error = null;\n\n  fs.stdin = STDIN;\n  fs.stdout = STDOUT;\n  fs.stderr = STDERR;\n\n  // Safely expose the list of open files and file\n  // descriptor management functions\n  var openFiles = {};\n  var nextDescriptor = FIRST_DESCRIPTOR;\n  Object.defineProperty(this, \"openFiles\", {\n    get: function() { return openFiles; }\n  });\n  this.allocDescriptor = function(openFileDescription) {\n    var fd = nextDescriptor ++;\n    openFiles[fd] = openFileDescription;\n    return fd;\n  };\n  this.releaseDescriptor = function(fd) {\n    delete openFiles[fd];\n  };\n\n  // Safely expose the operation queue\n  var queue = [];\n  this.queueOrRun = function(operation) {\n    var error;\n\n    if(FS_READY == fs.readyState) {\n      operation.call(fs);\n    } else if(FS_ERROR == fs.readyState) {\n      error = new Errors.EFILESYSTEMERROR('unknown error');\n    } else {\n      queue.push(operation);\n    }\n\n    return error;\n  };\n  function runQueued() {\n    queue.forEach(function(operation) {\n      operation.call(this);\n    }.bind(fs));\n    queue = null;\n  }\n\n  // We support the optional `options` arg from node, but ignore it\n  this.watch = function(filename, options, listener) {\n    if(isNullPath(filename)) {\n      throw new Error('Path must be a string without null bytes.');\n    }\n    if(typeof options === 'function') {\n      listener = options;\n      options = {};\n    }\n    options = options || {};\n    listener = listener || nop;\n\n    var watcher = new FSWatcher();\n    watcher.start(filename, false, options.recursive);\n    watcher.on('change', listener);\n\n    return watcher;\n  };\n\n  // Deal with various approaches to node ID creation\n  function wrappedGuidFn(context) {\n    return function(callback) {\n      // Skip the duplicate ID check if asked to\n      if(_(flags).contains(FS_NODUPEIDCHECK)) {\n        callback(null, guid());\n        return;\n      }\n\n      // Otherwise (default) make sure this id is unused first\n      function guidWithCheck(callback) {\n        var id = guid();\n        context.getObject(id, function(err, value) {\n          if(err) {\n            callback(err);\n            return;\n          }\n\n          // If this id is unused, use it, otherwise find another\n          if(!value) {\n            callback(null, id);\n          } else {\n            guidWithCheck(callback);\n          }\n        });\n      }\n      guidWithCheck(callback);\n    };\n  }\n\n  // Let other instances (in this or other windows) know about\n  // any changes to this fs instance.\n  function broadcastChanges(changes) {\n    if(!changes.length) {\n      return;\n    }\n    var intercom = Intercom.getInstance();\n    changes.forEach(function(change) {\n      intercom.emit(change.event, change.path);\n    });\n  }\n\n  // Open file system storage provider\n  provider.open(function(err) {\n    function complete(error) {\n      function wrappedContext(methodName) {\n        var context = provider[methodName]();\n        context.flags = flags;\n        context.changes = [];\n        context.guid = wrappedGuidFn(context);\n\n        // When the context is finished, let the fs deal with any change events\n        context.close = function() {\n          var changes = context.changes;\n          broadcastChanges(changes);\n          changes.length = 0;\n        };\n\n        return context;\n      }\n\n      // Wrap the provider so we can extend the context with fs flags and\n      // an array of changes (e.g., watch event 'change' and 'rename' events\n      // for paths updated during the lifetime of the context). From this\n      // point forward we won't call open again, so it's safe to drop it.\n      fs.provider = {\n        openReadWriteContext: function() {\n          return wrappedContext('getReadWriteContext');\n        },\n        openReadOnlyContext: function() {\n          return wrappedContext('getReadOnlyContext');\n        }\n      };\n\n      if(error) {\n        fs.readyState = FS_ERROR;\n      } else {\n        fs.readyState = FS_READY;\n      }\n      runQueued();\n      callback(error, fs);\n    }\n\n    if(err) {\n      return complete(err);\n    }\n\n    var context = provider.getReadWriteContext();\n    context.guid = wrappedGuidFn(context);\n\n    // Mount the filesystem, formatting if necessary\n    if(forceFormatting) {\n      // Wipe the storage provider, then write root block\n      context.clear(function(err) {\n        if(err) {\n          return complete(err);\n        }\n        impl.ensureRootDirectory(context, complete);\n      });\n    } else {\n      // Use existing (or create new) root and mount\n      impl.ensureRootDirectory(context, complete);\n    }\n  });\n}\n\n// Expose storage providers on FileSystem constructor\nFileSystem.providers = providers;\n\n/**\n * Public API for FileSystem\n */\n[\n  'open',\n  'close',\n  'mknod',\n  'mkdir',\n  'rmdir',\n  'stat',\n  'fstat',\n  'link',\n  'unlink',\n  'read',\n  'readFile',\n  'write',\n  'writeFile',\n  'appendFile',\n  'exists',\n  'lseek',\n  'readdir',\n  'rename',\n  'readlink',\n  'symlink',\n  'lstat',\n  'truncate',\n  'ftruncate',\n  'utimes',\n  'futimes',\n  'setxattr',\n  'getxattr',\n  'fsetxattr',\n  'fgetxattr',\n  'removexattr',\n  'fremovexattr'\n].forEach(function(methodName) {\n  FileSystem.prototype[methodName] = function() {\n    var fs = this;\n    var args = Array.prototype.slice.call(arguments, 0);\n    var lastArgIndex = args.length - 1;\n\n    // We may or may not get a callback, and since node.js supports\n    // fire-and-forget style fs operations, we have to dance a bit here.\n    var missingCallback = typeof args[lastArgIndex] !== 'function';\n    var callback = maybeCallback(args[lastArgIndex]);\n\n    var error = fs.queueOrRun(function() {\n      var context = fs.provider.openReadWriteContext();\n\n      // Fail early if the filesystem is in an error state (e.g.,\n      // provider failed to open.\n      if(FS_ERROR === fs.readyState) {\n        var err = new Errors.EFILESYSTEMERROR('filesystem unavailable, operation canceled');\n        return callback.call(fs, err);\n      }\n\n      // Wrap the callback so we can explicitly close the context\n      function complete() {\n        context.close();\n        callback.apply(fs, arguments);\n      }\n\n      // Either add or replace the callback with our wrapper complete()\n      if(missingCallback) {\n        args.push(complete);\n      } else {\n        args[lastArgIndex] = complete;\n      }\n\n      // Forward this call to the impl's version, using the following\n      // call signature, with complete() as the callback/last-arg now:\n      // fn(fs, context, arg0, arg1, ... , complete);\n      var fnArgs = [fs, context].concat(args);\n      impl[methodName].apply(null, fnArgs);\n    });\n    if(error) {\n      callback(error);\n    }\n  };\n});\n\nFileSystem.prototype.Shell = function(options) {\n  return new Shell(this, options);\n};\n\nmodule.exports = FileSystem;\n","module.exports = {\n  FileSystem: require('./filesystem/interface.js'),\n  Buffer: require('./buffer.js'),\n  Path: require('./path.js'),\n  Errors: require('./errors.js')\n};\n"]}